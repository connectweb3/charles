<!doctype html>
<html lang="en">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" type="image/png" href="favicon.png" />
  <title>ADA Arcana - Card Pack Opening</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Orbitron:wght@400;600;800&display=swap"
    rel="stylesheet"
  />
  <style>
    :root {
      --c-common: #b0b0b0;
      --c-uncommon: #00ff66;
      --c-rare: #00eaff;
      --c-epic: #d000ff;
      --c-legendary: #ffd700;
      --c-mythic: #ff4d00;
      --c-celestials: #ffffff;
    }

    body {
      margin: 0;
      overflow: hidden;
      background-color: #050510;
      font-family: Orbitron, system-ui, -apple-system, Segoe UI, Roboto, Arial,
        sans-serif;
      color: #fff;
    }

    #ui-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    #instruction {
      position: absolute;
      bottom: 10%;
      width: 100%;
      text-align: center;
      font-size: 1.5rem;
      text-transform: uppercase;
      letter-spacing: 4px;
      opacity: 0.8;
      text-shadow: 0 0 10px rgba(0, 234, 255, 0.7);
      pointer-events: none;
    }

    .rarity-badge {
      position: absolute;
      padding: 5px 10px;
      border-radius: 4px;
      font-weight: 700;
      text-transform: uppercase;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.5s;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      color: var(--c-rare);
    }

    #pack-selection {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(92%, 720px);
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(0, 234, 255, 0.45);
      border-radius: 12px;
      padding: 14px;
      pointer-events: auto;
      box-shadow: 0 0 24px rgba(0, 234, 255, 0.25);
      z-index: 20;
    }

    #pack-selection .pack-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    #pack-modal-title {
      font-size: 18px;
      font-weight: 800;
      text-align: center;
      letter-spacing: 2px;
      margin: 6px 0 6px 0;
      color: #e8faff;
      text-transform: uppercase;
      text-shadow: 0 0 8px rgba(0, 234, 255, 0.6);
    }

    #pack-modal-title .pack-balance-row {
      margin-top: 4px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px 16px;
      font-size: 9px;
      font-weight: 500;
      letter-spacing: 0.4px;
      text-transform: none;
      color: #9fdcff;
      opacity: 0.95;
    }

    #pack-modal-title .pack-badge {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0, 234, 255, 0.35);
      background: rgba(2, 10, 20, 0.9);
      box-shadow: 0 0 6px rgba(0, 234, 255, 0.18);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    #pack-modal-title .pack-badge span.label {
      font-size: 8px;
      text-transform: uppercase;
      color: #e8faff;
      opacity: 0.9;
    }

    #pack-modal-title .pack-badge span.count {
      font-size: 9px;
      font-weight: 700;
      color: #ffd700;
    }

    .pack-rates {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 2px 12px;
      font-size: 11px;
      line-height: 1.3;
      margin-top: 4px;
      opacity: 0.9;
    }

    .pack-rates .rate-line {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .pack-rates .rate-label {
      font-weight: 700;
      text-transform: uppercase;
    }

    .pack-rates .rate-val {
      opacity: 0.85;
    }

    .pack-item {
      display: flex;
      gap: 10px;
      align-items: center;
      background: rgba(10, 10, 20, 0.7);
      border: 1px solid rgba(0, 234, 255, 0.25);
      border-radius: 8px;
      padding: 8px;
      cursor: pointer;
      transition: transform 0.2s ease, border-color 0.2s ease;
    }

    .pack-item:hover {
      transform: translateY(-2px);
      border-color: rgba(0, 234, 255, 0.6);
    }

    .pack-thumb {
      width: 72px;
      height: 108px;
      background-size: cover;
      background-position: center;
      border-radius: 6px;
      flex: 0 0 auto;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }

    .pack-meta {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .pack-title {
      font-weight: 700;
      font-size: 14px;
      color: #e8faff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .pack-desc {
      font-size: 12px;
      line-height: 1.25;
      opacity: 0.9;
    }

    #modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(2px);
      pointer-events: auto;
      z-index: 15;
    }

    .pack-item.selected {
      border-color: rgba(0, 234, 255, 0.9);
      box-shadow: 0 0 16px rgba(0, 234, 255, 0.35);
    }

    .pack-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 6px;
      display: block;
    }

    .modal-footer {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
    }

    .btn {
      pointer-events: auto;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid rgba(0, 234, 255, 0.35);
      background: rgba(10, 10, 20, 0.8);
      color: #e8faff;
      cursor: pointer;
      font-weight: 600;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      border-color: rgba(0, 234, 255, 0.7);
      background: rgba(0, 40, 50, 0.6);
    }

    body {
      background: radial-gradient(
          1200px 800px at 50% 60%,
          rgba(0, 234, 255, 0.06),
          rgba(0, 0, 0, 0) 60%
        ),
        radial-gradient(
          800px 600px at 50% -10%,
          rgba(212, 175, 55, 0.08),
          rgba(0, 0, 0, 0) 60%
        ),
        #050510;
    }

    #instruction {
      font-family: Cinzel, serif;
      text-shadow: 0 0 8px rgba(0, 234, 255, 0.6),
        0 0 14px rgba(212, 175, 55, 0.35);
    }

    #pack-selection {
      background: linear-gradient(
          180deg,
          rgba(10, 10, 18, 0.85) 0,
          rgba(5, 5, 16, 0.9) 100%
        ) !important;
      border: 1px solid rgba(212, 175, 55, 0.45) !important;
      box-shadow: 0 0 24px rgba(0, 234, 255, 0.25),
        inset 0 0 12px rgba(212, 175, 55, 0.25) !important;
    }

    .pack-item {
      border: 1px solid rgba(212, 175, 55, 0.25) !important;
      background: rgba(10, 10, 20, 0.7) !important;
    }

    .pack-item.selected {
      border-color: rgba(212, 175, 55, 0.9) !important;
      box-shadow: 0 0 16px rgba(212, 175, 55, 0.35) !important;
    }

    .btn {
      border-radius: 8px !important;
      border: 1px solid rgba(212, 175, 55, 0.5) !important;
      background: linear-gradient(
          180deg,
          rgba(20, 20, 30, 0.9) 0,
          rgba(5, 5, 16, 0.9) 100%
        ) !important;
      font-weight: 700 !important;
      text-shadow: 0 0 6px rgba(0, 234, 255, 0.35);
      box-shadow: 0 0 10px rgba(0, 234, 255, 0.18),
        inset 0 0 6px rgba(212, 175, 55, 0.18);
    }

    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 0 16px rgba(0, 234, 255, 0.35),
        inset 0 0 10px rgba(212, 175, 55, 0.3);
    }

    .btn-primary {
      border-color: rgba(0, 234, 255, 0.7) !important;
      background: linear-gradient(
          180deg,
          rgba(0, 40, 50, 0.7) 0,
          rgba(0, 20, 30, 0.6) 100%
        ) !important;
    }

    #post-open-actions {
      z-index: 30;
      pointer-events: auto;
    }

    #card-info-panel {
      z-index: 18;
      pointer-events: none;
      font-family: Cinzel, serif;
    }

    #backpack-btn {
      position: absolute;
      top: 14px;
      right: 14px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 1px solid rgba(212, 175, 55, 0.3);
      background: url("icon/backpack.jpg") center/70% no-repeat #0a0a14;
      box-shadow: 0 0 6px rgba(255, 255, 255, 0.08),
        inset 0 0 4px rgba(212, 175, 55, 0.12);
      z-index: 40;
      pointer-events: auto;
      cursor: pointer;
    }

    #backpack-btn:active,
    #backpack-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.18),
        0 0 16px rgba(0, 234, 255, 0.18),
        inset 0 0 8px rgba(212, 175, 55, 0.22);
    }

    #inventory-panel {
      position: absolute;
      top: 80px;
      right: 14px;
      width: min(420px, 92vw);
      max-height: 70vh;
      overflow: auto;
      background: linear-gradient(
          180deg,
          rgba(10, 10, 18, 0.92) 0,
          rgba(5, 5, 16, 0.95) 100%
        );
      border: 1px solid rgba(212, 175, 55, 0.45);
      border-radius: 10px;
      padding: 10px;
      box-shadow: 0 0 24px rgba(0, 234, 255, 0.25),
        inset 0 0 12px rgba(212, 175, 55, 0.25);
      z-index: 38;
      pointer-events: auto;
    }

    .inv-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }

    .inv-title {
      font-family: Cinzel, serif;
      font-weight: 800;
      letter-spacing: 1px;
      text-shadow: 0 0 8px rgba(0, 234, 255, 0.6);
    }

    .inv-tabs {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
      font-size: 9px;
      text-transform: uppercase;
      font-family: Orbitron, system-ui, sans-serif;
    }

    .inv-tab {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0, 234, 255, 0.4);
      background: rgba(0, 0, 0, 0.6);
      cursor: pointer;
      opacity: 0.7;
      transition: all 0.16s ease;
    }

    .inv-tab:hover {
      opacity: 1;
      box-shadow: 0 0 8px rgba(0, 234, 255, 0.35);
    }

    .inv-tab.active {
      opacity: 1;
      border-color: rgba(212, 175, 55, 0.9);
      color: #ffd700;
      box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
    }

    .inv-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }

    .inv-item {
      position: relative;
      border: 1px solid rgba(0, 234, 255, 0.25);
      background: rgba(0, 0, 0, 0.35);
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
    }

    /* Used NFT visual state */
    .inv-item.nft-used {
      opacity: 0.32;
      filter: grayscale(0.5);
      border-color: rgba(255, 77, 77, 0.95) !important;
      box-shadow: 0 0 10px rgba(255, 77, 77, 0.8) inset;
    }

    .inv-item.nft-used::after {
      content: "USED";
      position: absolute;
      top: 6px;
      left: 6px;
      padding: 2px 6px;
      font-size: 8px;
      font-weight: 800;
      color: #ffffff;
      background: rgba(255, 0, 0, 0.96);
      border-radius: 4px;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.9);
      letter-spacing: 1px;
      pointer-events: none;
    }

    /* Inventory card action tooltip */
    #inv-action-tooltip {
      position: fixed;
      z-index: 50;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0, 234, 255, 0.6);
      background: rgba(5, 5, 16, 0.96);
      box-shadow: 0 0 10px rgba(0, 234, 255, 0.35);
      font-family: Orbitron, system-ui, sans-serif;
      font-size: 8px;
      color: #e8faff;
      display: none;
      pointer-events: auto;
    }

    #inv-action-tooltip button {
      display: block;
      width: 100%;
      margin: 2px 0;
      padding: 3px 6px;
      border-radius: 6px;
      border: 1px solid rgba(0, 234, 255, 0.4);
      background: rgba(0, 0, 0, 0.9);
      color: #e8faff;
      font-size: 8px;
      text-align: left;
      cursor: pointer;
    }

    #inv-action-tooltip button:hover {
      border-color: rgba(212, 175, 55, 0.9);
      box-shadow: 0 0 8px rgba(212, 175, 55, 0.5);
    }

    .inv-item img {
      width: 100%;
      aspect-ratio: 2/3;
      object-fit: cover;
      display: block;
    }

    .inv-count-badge {
      position: absolute;
      bottom: 6px;
      right: 6px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(212, 175, 55, 0.7);
      border-radius: 12px;
      padding: 2px 6px;
      font-size: 12px;
      font-weight: 700;
    }

    #hover-tooltip {
      z-index: 44;
      pointer-events: none;
      font-family: Cinzel, serif;
    }

    #preloader {
      position: fixed;
      inset: 0;
      background: radial-gradient(
          1000px 700px at 50% 60%,
          rgba(0, 234, 255, 0.08),
          rgba(0, 0, 0, 0) 60%
        ),
        radial-gradient(
          800px 500px at 50% -10%,
          rgba(212, 175, 55, 0.1),
          rgba(0, 0, 0, 0) 60%
        ),
        #050510;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      pointer-events: auto;
      transition: opacity 0.7s ease;
    }

    #preloader.hide {
      opacity: 0;
      pointer-events: none;
    }

    .preloader-inner {
      width: min(560px, 92vw);
      background: linear-gradient(
          180deg,
          rgba(10, 10, 18, 0.92) 0,
          rgba(5, 5, 16, 0.96) 100%
        );
      border: 1px solid rgba(212, 175, 55, 0.5);
      border-radius: 12px;
      padding: 18px 16px;
      box-shadow: 0 0 24px rgba(0, 234, 255, 0.25),
        inset 0 0 12px rgba(212, 175, 55, 0.22);
      text-align: center;
    }

    .preloader-logo {
      font-family: Cinzel, serif;
      font-size: 28px;
      font-weight: 900;
      letter-spacing: 2px;
      color: #e8faff;
      text-shadow: 0 0 10px rgba(0, 234, 255, 0.55),
        0 0 16px rgba(212, 175, 55, 0.35);
      margin-bottom: 6px;
    }

    .preloader-sub {
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 12px;
    }

    .preloader-bar {
      position: relative;
      height: 10px;
      border-radius: 6px;
      border: 1px solid rgba(0, 234, 255, 0.45);
      background: rgba(0, 0, 0, 0.35);
      overflow: hidden;
      box-shadow: inset 0 0 10px rgba(0, 234, 255, 0.15);
    }

    #preload-bar-fill {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(
        90deg,
        rgba(0, 234, 255, 0.8),
        rgba(212, 175, 55, 0.8)
      );
      box-shadow: 0 0 12px rgba(0, 234, 255, 0.45);
      transition: width 0.2s ease;
    }

    .preloader-meta {
      font-size: 12px;
      opacity: 0.85;
      margin-top: 8px;
      letter-spacing: 1px;
    }

    /* CONNECT WALLET BUTTON (center, appears after preload) */
    #connect-wallet-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 14px 32px;
      border-radius: 999px;
      border: 1px solid rgba(212, 175, 55, 0.85);
      background: radial-gradient(
          circle at 0 0,
          rgba(0, 234, 255, 0.18),
          transparent
        ),
        radial-gradient(
          circle at 100% 0,
          rgba(212, 175, 55, 0.22),
          transparent
        ),
        rgba(5, 5, 16, 0.96);
      color: #e8faff;
      font-family: Cinzel, serif;
      font-weight: 800;
      font-size: 18px;
      letter-spacing: 3px;
      text-transform: uppercase;
      box-shadow: 0 0 18px rgba(0, 234, 255, 0.3),
        0 0 26px rgba(212, 175, 55, 0.22);
      cursor: pointer;
      display: none;
      z-index: 50;
      pointer-events: auto;
      text-shadow: 0 0 8px rgba(0, 234, 255, 0.6);
    }

    #connect-wallet-btn:hover {
      transform: translate(-50%, -52%);
      box-shadow: 0 0 26px rgba(0, 234, 255, 0.5),
        0 0 34px rgba(212, 175, 55, 0.32);
    }

    #connect-wallet-btn:active {
      transform: translate(-50%, -48%);
      box-shadow: 0 0 16px rgba(0, 234, 255, 0.35),
        0 0 24px rgba(212, 175, 55, 0.26);
    }

    /* WALLET MODAL */
    #wallet-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(3px);
      z-index: 60;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    #wallet-modal {
      width: min(420px, 92vw);
      background: linear-gradient(
          180deg,
          rgba(10, 10, 18, 0.98) 0,
          rgba(5, 5, 16, 0.98) 100%
        );
      border-radius: 14px;
      border: 1px solid rgba(212, 175, 55, 0.6);
      box-shadow: 0 0 28px rgba(0, 234, 255, 0.28),
        inset 0 0 14px rgba(212, 175, 55, 0.26);
      padding: 16px 14px 12px;
      color: #e8faff;
      font-family: Cinzel, serif;
      pointer-events: auto;
    }

    #wallet-modal-title {
      font-size: 18px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
      margin-bottom: 4px;
      text-shadow: 0 0 8px rgba(0, 234, 255, 0.6);
    }

    #wallet-modal-sub {
      font-size: 11px;
      opacity: 0.82;
      text-align: center;
      margin-bottom: 10px;
      font-family: Orbitron, system-ui, sans-serif;
    }

    #wallet-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 10px;
    }

    .wallet-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 9px;
      border-radius: 8px;
      border: 1px solid rgba(0, 234, 255, 0.26);
      background: radial-gradient(
          circle at 0 0,
          rgba(0, 234, 255, 0.06),
          transparent
        ),
        rgba(3, 5, 12, 0.95);
      cursor: pointer;
      transition: all 0.18s ease;
      font-family: Orbitron, system-ui, sans-serif;
      font-size: 11px;
    }

    .wallet-item-left {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }

    .wallet-name {
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .wallet-label {
      font-size: 9px;
      opacity: 0.8;
    }

    .wallet-status {
      font-size: 9px;
      padding: 3px 6px;
      border-radius: 999px;
      border: 1px solid rgba(0, 234, 255, 0.55);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .wallet-item.detected {
      border-color: rgba(0, 234, 255, 0.7);
      box-shadow: 0 0 10px rgba(0, 234, 255, 0.32);
    }

    .wallet-item:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 14px rgba(0, 234, 255, 0.35);
      border-color: rgba(212, 175, 55, 0.7);
    }

    .wallet-item.disabled,
    .wallet-item.disabled:hover {
      cursor: not-allowed;
      opacity: 0.38;
      box-shadow: none;
      border-style: dashed;
      transform: none;
    }

    .wallet-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
    }

    .wallet-note {
      font-size: 8px;
      opacity: 0.7;
      font-family: Orbitron, system-ui, sans-serif;
    }

    .wallet-close-btn {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(212, 175, 55, 0.6);
      background: rgba(5, 5, 16, 0.98);
      color: #e8faff;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      font-family: Orbitron, system-ui, sans-serif;
    }

    .wallet-close-btn:hover {
      box-shadow: 0 0 10px rgba(0, 234, 255, 0.3);
    }

    #wallet-error {
      margin-top: 4px;
      font-size: 9px;
      color: #ff4d4d;
      min-height: 10px;
    }

    #connected-wallet-pill {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(0, 234, 255, 0.6);
      background: rgba(5, 5, 16, 0.96);
      font-size: 9px;
      font-family: Orbitron, system-ui, sans-serif;
      letter-spacing: 1px;
      text-transform: uppercase;
      display: none;
      z-index: 45;
      box-shadow: 0 0 12px rgba(0, 234, 255, 0.35);
    }

    #connected-wallet-pill span {
      color: rgba(212, 175, 55, 0.96);
      margin-left: 4px;
    }

    /* PROFILE TAB (top-left) */
    #profile-tab {
      position: absolute;
      top: 14px;
      left: 14px;
      padding: 8px 14px;
      border-radius: 10px;
      border: 1px solid rgba(212, 175, 55, 0.6);
      background: radial-gradient(circle at 0 0, rgba(0, 234, 255, 0.14), transparent),
                  rgba(5, 5, 16, 0.96);
      color: #e8faff;
      font-family: Cinzel, serif;
      font-weight: 700;
      font-size: 11px;
      letter-spacing: 1px;
      text-transform: uppercase;
      display: none;
      cursor: pointer;
      box-shadow: 0 0 14px rgba(0, 234, 255, 0.32), 0 0 18px rgba(212, 175, 55, 0.22);
      z-index: 46;
      pointer-events: auto;
    }

    #profile-tab span {
      display: block;
      font-family: Orbitron, system-ui, sans-serif;
      font-size: 9px;
      font-weight: 500;
      opacity: 0.85;
      margin-top: 2px;
    }

    /* SHOP BUTTON (top-right beside inventory) */
    #shop-btn {
      position: absolute;
      top: 14px;
      right: 82px; /* 56px backpack + ~12px gap */
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 1px solid rgba(0, 234, 255, 0.4);
      background: radial-gradient(circle at 30% 0, rgba(0,234,255,0.22), transparent),
                  radial-gradient(circle at 70% 100%, rgba(212,175,55,0.18), transparent),
                  #050515;
      box-shadow: 0 0 6px rgba(0, 234, 255, 0.18),
                  inset 0 0 4px rgba(0, 234, 255, 0.18);
      z-index: 40;
      pointer-events: auto;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: Orbitron, system-ui, sans-serif;
      font-size: 8px;
      font-weight: 700;
      letter-spacing: 0.5px;
      color: #e8faff;
      text-align: center;
      text-transform: uppercase;
    }

    #shop-btn::before {
      content: "SHOP";
    }

    #shop-btn:hover,
    #shop-btn:active {
      transform: translateY(-1px);
      box-shadow: 0 0 10px rgba(0, 234, 255, 0.35),
                  0 0 16px rgba(212, 175, 55, 0.22),
                  inset 0 0 6px rgba(0, 234, 255, 0.25);
    }

    /* SHOP PANEL */
    #shop-panel {
      position: absolute;
      top: 70px;
      left: 14px;
      width: min(380px, 92vw);
      max-height: 72vh;
      padding: 10px 10px 8px;
      border-radius: 10px;
      border: 1px solid rgba(0, 234, 255, 0.6);
      background: linear-gradient(180deg, rgba(10, 10, 18, 0.98), rgba(5, 5, 16, 0.98));
      box-shadow: 0 0 24px rgba(0, 234, 255, 0.28), inset 0 0 12px rgba(212, 175, 55, 0.26);
      color: #e8faff;
      font-family: Orbitron, system-ui, sans-serif;
      font-size: 10px;
      display: none;
      z-index: 45;
      pointer-events: auto;
    }

    #shop-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    #shop-title {
      font-family: Cinzel, serif;
      font-size: 13px;
      font-weight: 800;
      letter-spacing: 1px;
      text-transform: uppercase;
      text-shadow: 0 0 8px rgba(0, 234, 255, 0.6);
    }

    #shop-close {
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(0, 234, 255, 0.7);
      background: rgba(5, 5, 16, 0.98);
      color: #e8faff;
      font-size: 9px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    #shop-close:hover {
      box-shadow: 0 0 8px rgba(0, 234, 255, 0.3);
    }

    #shop-tabs {
      display: flex;
      gap: 6px;
      margin: 4px 0 6px;
      font-size: 9px;
      text-transform: uppercase;
    }

    .shop-tab {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0, 234, 255, 0.4);
      background: rgba(0, 0, 0, 0.6);
      cursor: pointer;
      opacity: 0.7;
      transition: all 0.16s ease;
      font-family: Orbitron, system-ui, sans-serif;
    }

    .shop-tab.active {
      opacity: 1;
      border-color: rgba(212, 175, 55, 0.9);
      color: #ffd700;
      box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
    }

    #shop-content {
      font-size: 9px;
      line-height: 1.4;
    }

    .shop-note {
      opacity: 0.78;
      margin-top: 4px;
      font-size: 8px;
    }

    /* EXCHANGE MODAL (embedded inside shop Packs view, non-blocking) */
    #exchange-modal {
      margin-top: 6px;
      width: 100%;
      max-height: 32vh;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0, 234, 255, 0.5);
      background: radial-gradient(circle at 0 0, rgba(0,234,255,0.12), transparent),
                  rgba(3,5,12,0.96);
      box-shadow: 0 0 12px rgba(0,234,255,0.22);
      color: #e8faff;
      font-family: Orbitron, system-ui, sans-serif;
      font-size: 8px;
      display: none;
      pointer-events: auto;
    }

    #exchange-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
      margin-bottom: 3px;
    }

    #exchange-modal-title {
      font-family: Cinzel, serif;
      font-size: 9px;
      font-weight: 700;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      text-shadow: 0 0 6px rgba(0,234,255,0.6);
    }

    #exchange-modal-close {
      padding: 1px 6px;
      border-radius: 999px;
      border: 1px solid rgba(0,234,255,0.7);
      background: rgba(5,5,16,0.98);
      color: #e8faff;
      font-size: 7px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    #exchange-modal-close:hover {
      box-shadow: 0 0 6px rgba(0,234,255,0.35);
    }

    #exchange-selected-list {
      margin: 2px 0 4px;
      padding: 3px;
      border-radius: 4px;
      border: 1px solid rgba(0,234,255,0.25);
      background: rgba(0,0,0,0.72);
      max-height: 18vh;
      overflow-y: auto;
      font-size: 7px;
      line-height: 1.4;
    }

    .exchange-card-row {
      display: flex;
      justify-content: space-between;
      gap: 4px;
      margin-bottom: 2px;
    }

    /* Glow highlight for cards selected in exchange mode */
    .inv-item.exchange-selected {
      box-shadow:
        0 0 10px rgba(0, 234, 255, 0.7),
        0 0 20px rgba(212, 175, 55, 0.6);
      border-color: rgba(212, 175, 55, 0.9);
      transform: translateY(-1px);
    }

    .exchange-card-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .exchange-card-remove {
      cursor: pointer;
      color: rgba(255,77,77,0.9);
      font-size: 7px;
      margin-left: 4px;
    }

    #exchange-count-label {
      margin-top: 2px;
      font-size: 7px;
      opacity: 0.8;
    }

    #exchange-confirm-btn {
      margin-top: 4px;
      width: 100%;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid rgba(212,175,55,0.7);
      background: linear-gradient(180deg, rgba(20,20,30,0.96), rgba(5,5,16,0.98));
      color: #e8faff;
      font-size: 8px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      cursor: pointer;
    }

    #exchange-confirm-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    #exchange-note {
      margin-top: 2px;
      font-size: 7px;
      opacity: 0.7;
    }

    /* Exchange Result Modal */
    #exchange-result-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(3px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 80;
      pointer-events: auto;
    }

    #exchange-result-modal {
      min-width: 260px;
      max-width: 360px;
      padding: 14px 16px 10px;
      border-radius: 10px;
      border: 1px solid rgba(212, 175, 55, 0.8);
      background: linear-gradient(
        180deg,
        rgba(10, 10, 18, 0.98),
        rgba(5, 5, 16, 0.98)
      );
      box-shadow: 0 0 22px rgba(0, 234, 255, 0.35),
        inset 0 0 10px rgba(212, 175, 55, 0.28);
      font-family: Cinzel, serif;
      text-align: center;
      color: #e8faff;
    }

    #exchange-result-title {
      font-size: 15px;
      font-weight: 800;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 4px;
      text-shadow: 0 0 6px rgba(0, 234, 255, 0.65);
    }

    #exchange-result-body {
      font-size: 9px;
      opacity: 0.9;
      margin-bottom: 8px;
      font-family: Orbitron, system-ui, sans-serif;
      line-height: 1.4;
    }

    #exchange-result-close {
      padding: 5px 14px;
      border-radius: 999px;
      border: 1px solid rgba(212, 175, 55, 0.8);
      background: rgba(5, 5, 16, 0.98);
      color: #e8faff;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      font-family: Orbitron, system-ui, sans-serif;
    }

    #exchange-result-close:hover {
      box-shadow: 0 0 10px rgba(0, 234, 255, 0.3);
    }

    #profile-dashboard {
      position: absolute;
      top: 70px;
      left: 14px;
      width: min(360px, 92vw);
      max-height: 72vh;
      padding: 10px 10px 8px;
      border-radius: 10px;
      border: 1px solid rgba(212, 175, 55, 0.6);
      background: linear-gradient(180deg, rgba(10, 10, 18, 0.98), rgba(5, 5, 16, 0.98));
      box-shadow: 0 0 24px rgba(0, 234, 255, 0.28), inset 0 0 12px rgba(212, 175, 55, 0.26);
      color: #e8faff;
      font-family: Orbitron, system-ui, sans-serif;
      font-size: 10px;
      display: none;
      z-index: 45;
      pointer-events: auto;
    }

    #profile-dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    #profile-dashboard-title {
      font-family: Cinzel, serif;
      font-size: 13px;
      font-weight: 800;
      letter-spacing: 1px;
      text-transform: uppercase;
      text-shadow: 0 0 8px rgba(0, 234, 255, 0.6);
    }

    #profile-dashboard-close {
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(212, 175, 55, 0.7);
      background: rgba(5, 5, 16, 0.98);
      color: #e8faff;
      font-size: 9px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    #profile-dashboard-close:hover {
      box-shadow: 0 0 8px rgba(0, 234, 255, 0.3);
    }

    .profile-row-label {
      font-size: 9px;
      opacity: 0.72;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 1px;
    }

    .profile-row-value {
      font-size: 9px;
      color: rgba(212, 175, 55, 0.96);
      word-break: break-all;
      margin-bottom: 4px;
    }

    .profile-nft-list {
      margin-top: 4px;
      display: grid;
      grid-template-columns: 1.4fr 0.8fr;
      column-gap: 6px;
      row-gap: 4px;
      align-items: center;
    }

    .profile-nft-name {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }

    .profile-nft-status {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 999px;
      text-align: center;
      border: 1px solid rgba(0, 234, 255, 0.45);
    }

    .profile-nft-status.yes {
      color: #00ff66;
      border-color: rgba(0, 255, 102, 0.7);
      box-shadow: 0 0 10px rgba(0, 255, 102, 0.4);
    }

    .profile-nft-status.no {
      color: #ff4d4d;
      border-color: rgba(255, 77, 77, 0.7);
    }

    #profile-error {
      margin-top: 3px;
      font-size: 8px;
      color: #ff4d4d;
      min-height: 10px;
    }
</style>
  </style>

  <body>
    <div
      id="preloader"
      aria-busy="true"
      aria-live="polite"
    >
      <div class="preloader-inner">
        <div class="preloader-logo">ADA ARCANA</div>
        <div class="preloader-sub">Initializing astral lattice...</div>
        <div class="preloader-bar">
          <span id="preload-bar-fill"></span>
        </div>
        <div class="preloader-meta">
          <span id="preload-count">0</span>/<span id="preload-total">0</span>
          assets • <span id="preload-percent">0%</span>
        </div>
      </div>
    </div>

    <!-- CONNECTED WALLET STATUS PILL -->
    <div id="connected-wallet-pill">
      Wallet:
      <span id="connected-wallet-label"></span>
    </div>

    <!-- PROFILE TAB -->
    <div id="profile-tab">
      PROFILE
      <span id="profile-tab-sub">Awaiting wallet...</span>
    </div>

    <!-- SHOP BUTTON -->
    <div id="shop-btn" title="Shop" aria-label="Shop"></div>
    <div id="profile-dashboard">
      <div id="profile-dashboard-header">
        <div id="profile-dashboard-title">Profile Dashboard</div>
        <button id="profile-dashboard-close" type="button">Close</button>
      </div>
      <div class="profile-row-label">Connected Wallet Key</div>
      <div class="profile-row-value" id="profile-wallet-key">-</div>
      <div class="profile-row-label">Stake Address</div>
      <div class="profile-row-value" id="profile-stake-address">-</div>
      <div class="profile-row-label">ADA Balance</div>
      <div class="profile-row-value" id="profile-ada-balance">-</div>
      <div class="profile-row-label">$COC Balance</div>
      <div class="profile-row-value" id="profile-coc-balance">Coming soon</div>

      <div id="profile-dashboard-pack-counts"></div>

      <div class="profile-row-label">Held Collections</div>
      <div class="profile-nft-list">
        <div class="profile-nft-name">Bison NFT</div>
        <div class="profile-nft-status" id="profile-bison-status">Checking...</div>
        <div class="profile-nft-name">Charles NFT</div>
        <div class="profile-nft-status" id="profile-charles-status">Checking...</div>
        <div class="profile-nft-name">Hallow Charles NFT</div>
        <div class="profile-nft-status" id="profile-hallow-status">Checking...</div>
      </div>
      <div class="profile-row-label">NFT ➜ Pack Exchange</div>
      <div class="profile-nft-list">
        <button
          id="btn-exchange-bison-nft"
          class="btn"
          type="button"
          style="font-size:8px;padding:4px 6px;"
        >
          Use 1 Bison NFT ➜ 2 Random Packs
        </button>
        <div></div>
        <button
          id="btn-exchange-charles-nft"
          class="btn"
          type="button"
          style="font-size:8px;padding:4px 6px;"
        >
          Use 1 Charles NFT ➜ 1 Random Pack
        </button>
        <div></div>
        <button
          id="btn-exchange-hallow-nft"
          class="btn"
          type="button"
          style="font-size:8px;padding:4px 6px;"
        >
          Use 1 Hallow Charles NFT ➜ 1 Random Pack
        </button>
        <div></div>
      </div>
      <div id="profile-error"></div>
    </div>

    <!-- SHOP PANEL -->
    <div id="shop-panel">
      <div id="shop-header">
        <div id="shop-title">Card Pack Shop</div>
        <button id="shop-close" type="button">Close</button>
      </div>
      <div id="shop-tabs">
        <div class="shop-tab active" data-shop-tab="packs">Packs</div>
        <div class="shop-tab" data-shop-tab="consign">Consignment</div>
      </div>
      <div id="shop-content">
        <div data-shop-view="packs">
          <!-- Packs tab: NFT + 20-card exchange and direct pack acquisition -->
          <!-- Embedded Pack Exchange Modal (lives inside shop so it never blocks the shop panel) -->
          <div id="exchange-modal">
            <div id="exchange-modal-header">
              <div id="exchange-modal-title">Pack Exchange (20 Cards)</div>
              <button id="exchange-modal-close" type="button">X</button>
            </div>
            <div id="exchange-selected-list">
              <div style="opacity:0.7;">
                No cards selected yet. Click the exchange button, then click cards in your Backpack to add them here.
              </div>
            </div>
            <div id="exchange-count-label">0 / 20 selected</div>
            <button id="exchange-confirm-btn" disabled="disabled">
              Confirm Exchange
            </button>
            <div id="exchange-note">
              Select 20 eligible cards to exchange for a random premium pack.
              Or exchange:
              1x Bison NFT ➜ 2 Random Packs,
              1x Charles NFT ➜ 1 Random Pack,
              1x Hallow Charles NFT ➜ 1 Random Pack.
              Backend / on-chain fulfillment required.
            </div>
          </div>
          <div style="margin-bottom:6px;font-weight:700;text-transform:uppercase;">Packs & Exchanges</div>
          <div style="margin-bottom:4px;">
            Spend
            <strong>20 Cards</strong>
            from your local inventory to receive
            <strong>1 Random Pack</strong>
            from:
            <em>Genesis Sigil</em>,
            <em>Crawju Forge</em>,
            <em>Bison Dominion</em>,
            <em>Celestial Chain</em>.
          </div>
          <button
            id="btn-exchange-20cards-random-pack"
            class="btn btn-primary"
            style="width:100%;margin:4px 0 6px 0;font-size:9px;"
          >
            Exchange 20 Cards for Random Premium Pack
          </button>
          <div style="font-size:8px;opacity:0.7;margin-bottom:6px;">
            On click, your Backpack inventory will open in \"Cards\" tab so the user can pick which 20 cards
            to exchange. Implement the actual burn/mint logic in pack.js or your backend.
          </div>
          <div style="font-size:8px;opacity:0.78;">
            You can also list fixed-price pack offers here by connecting to your marketplace / policy IDs.
          </div>
        </div>
        <div data-shop-view="consign" style="display:none">
          <!-- Consignment tab: list cards for sale or for pack trades -->
          <div style="margin-bottom:6px;font-weight:700;text-transform:uppercase;">Consignment Listings</div>
          <div style="font-size:8px;opacity:0.8;margin-bottom:4px;">
            Put your cards up for:
            <br />- Direct sale (ADA)
            <br />- Pack-for-card trades (specify which pack and quantity)
          </div>
          <div style="margin:4px 0;padding:6px;border-radius:6px;border:1px solid rgba(0,234,255,0.35);background:rgba(0,0,0,0.6);">
            <div style="font-size:8px;margin-bottom:4px;">Select card(s) from your Backpack inventory UI to consign.</div>
            <label style="display:block;font-size:8px;margin-bottom:2px;">
              Quantity:
              <input
                id="consign-qty"
                type="number"
                min="1"
                value="1"
                style="width:60px;font-size:8px;margin-left:4px;"
              />
            </label>
            <label style="display:block;font-size:8px;margin-bottom:2px;">
              Mode:
              <select id="consign-mode" style="font-size:8px;margin-left:4px;">
                <option value="sale">Sell for ADA</option>
                <option value="pack-trade">Trade for Packs</option>
              </select>
            </label>
            <label style="display:block;font-size:8px;margin-bottom:2px;">
              Price / Requested Packs:
              <input
                id="consign-price-or-packs"
                type="text"
                placeholder="e.g. 25 ADA or 2x Genesis Sigil"
                style="width:100%;font-size:8px;margin-top:2px;"
              />
            </label>
            <button
              id="btn-consign-submit"
              class="btn btn-primary"
              style="width:100%;margin-top:4px;font-size:9px;"
            >
              List Consignment
            </button>
          </div>
          <div style="font-size:8px;opacity:0.7;">
            Configure this consignment flow with your marketplace / smart contract to settle sales and pack-based offers.
          </div>
        </div>
      </div>
      <div class="shop-note">
        Ensure your marketplace / contracts handle pack exchange and consignment settlement for production use.
      </div>
    </div>

    <!-- CONNECT WALLET BUTTON (center, appears after preload) -->
    <button
      id="connect-wallet-btn"
      type="button"
    >
      CONNECT WALLET
    </button>

    <!-- Exchange Result Modal Host -->
    <div id="exchange-result-backdrop">
      <div id="exchange-result-modal">
        <div id="exchange-result-title">Exchange Result</div>
        <div id="exchange-result-body"></div>
        <button id="exchange-result-close" type="button">Close</button>
      </div>
    </div>

    <!-- WALLET SELECT MODAL -->
    <div id="wallet-modal-backdrop">
      <div id="wallet-modal" onclick="event.stopPropagation()">
        <div id="wallet-modal-title">Connect Cardano Wallet</div>
        <div id="wallet-modal-sub">
          Select a CIP-30 compatible wallet to begin opening packs.
        </div>
        <div id="wallet-list">
          <div class="wallet-item" data-wallet-key="lace">
            <div class="wallet-item-left">
              <div class="wallet-name">Lace</div>
              <div class="wallet-label">Official light wallet by IOG</div>
            </div>
            <div class="wallet-status">Not detected</div>
          </div>
          <div class="wallet-item" data-wallet-key="vespr">
            <div class="wallet-item-left">
              <div class="wallet-name">Vespr</div>
              <div class="wallet-label">Modern Cardano wallet</div>
            </div>
            <div class="wallet-status">Not detected</div>
          </div>
          <div class="wallet-item" data-wallet-key="eternl">
            <div class="wallet-item-left">
              <div class="wallet-name">Eternl</div>
              <div class="wallet-label">Power user wallet</div>
            </div>
            <div class="wallet-status">Not detected</div>
          </div>
          <div class="wallet-item" data-wallet-key="nami">
            <div class="wallet-item-left">
              <div class="wallet-name">Nami</div>
              <div class="wallet-label">Browser extension wallet</div>
            </div>
            <div class="wallet-status">Not detected</div>
          </div>
          <div class="wallet-item" data-wallet-key="flint">
            <div class="wallet-item-left">
              <div class="wallet-name">Flint</div>
              <div class="wallet-label">Cross-platform wallet</div>
            </div>
            <div class="wallet-status">Not detected</div>
          </div>
          <div class="wallet-item" data-wallet-key="typhoncip30">
            <div class="wallet-item-left">
              <div class="wallet-name">Typhon</div>
              <div class="wallet-label">Typhon CIP-30</div>
            </div>
            <div class="wallet-status">Not detected</div>
          </div>
          <div class="wallet-item" data-wallet-key="gerowallet">
            <div class="wallet-item-left">
              <div class="wallet-name">GeroWallet</div>
              <div class="wallet-label">DeFi wallet</div>
            </div>
            <div class="wallet-status">Not detected</div>
          </div>
          <div class="wallet-item" data-wallet-key="yoroi">
            <div class="wallet-item-left">
              <div class="wallet-name">Yoroi</div>
              <div class="wallet-label">Emurgo light wallet</div>
            </div>
            <div class="wallet-status">Not detected</div>
          </div>
          <div class="wallet-item" data-wallet-key="nufi">
            <div class="wallet-item-left">
              <div class="wallet-name">NuFi</div>
              <div class="wallet-label">Multi-chain wallet</div>
            </div>
            <div class="wallet-status">Not detected</div>
          </div>
        </div>
        <div id="wallet-error"></div>
        <div class="wallet-footer">
          <div class="wallet-note">
            Only detected wallets are clickable. Install from official sources if missing.
          </div>
          <button
            class="wallet-close-btn"
            type="button"
            id="wallet-close-btn"
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <div id="ui-container">
      <div id="modal-backdrop"></div>

      <div id="pack-selection">
        <div id="pack-modal-title">CELESTIAL GENESIS PACK</div>
        <div class="pack-grid" id="pack-grid"></div>
        <div class="modal-footer">
          <button
            id="confirm-pack"
            class="btn btn-primary"
            disabled="disabled"
          >
            Confirm
          </button>
          <button
            id="cancel-pack"
            class="btn"
          >
            Cancel
          </button>
        </div>
      </div>
      <div id="instruction">Connect your wallet to begin</div>
      <div id="loading">LOADING ADA ARCANA...</div>
      <button
        id="backpack-btn"
        title="Inventory"
        aria-label="Inventory"
      ></button>
      <div id="inventory-panel" style="display: none">
        <div class="inv-header">
          <div class="inv-title">Backpack</div>
          <button class="inv-close btn">Close</button>
        </div>
        <div class="inv-tabs">
          <div class="inv-tab active" data-tab="cards">Cards</div>
          <div class="inv-tab" data-tab="bison">Bison NFT</div>
          <div class="inv-tab" data-tab="charles">Charles NFT</div>
          <div class="inv-tab" data-tab="hallow">Hallow NFT</div>
        </div>
        <div class="inv-grid" id="inv-grid"></div>
      </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script type="module">
      import * as THREE from "three";
      import { renderProfilePackCounts, tryConsumeForPack, getPackBalances } from "./pack.js";
      import { supabase, ensureUser, savePackBalances, logPackOpen, recordNftExchange } from "./supabase_client.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { OutputPass } from "three/addons/postprocessing/OutputPass.js";

      // --- CONFIG ---
      const CONFIG = {
        colors: {
          common: 0xb0b0b0,
          uncommon: 0x00ff66,
          rare: 0x00eaff,
          epic: 0xd000ff,
          legendary: 0xffd700,
          mythic: 0xff4d00,
          celestials: 0xffffff,
          bg: 0x050510,
          grid: 0x0a0a20
        },
        cardSize: { w: 2.5, h: 3.5, d: 0.05 }
      };

      // --- GLOBAL WALLET STATE / GATE ---
      let connectedWallet = null;
      let currentUserId = null; // Supabase users.id for this wallet

      let profileData = {
        stakeAddress: null,
        adaBalance: null,
        cocBalance: null,
        nftHoldings: {
          bison: false,
          charles: false,
          hallow: false
        }
      };

      // Remote on-chain data API (read-only, provider hidden from UI)
      const BLOCKFROST_API_KEY = "mainneteJV1JebLx0eqrIQYY3eYEQeGqIWvOpCF";
      const BLOCKFROST_BASE = "https://cardano-mainnet.blockfrost.io/api/v0";

      const POLICY_IDS = {
        bison: "584af8907c477e897ec19a1bbf34a6bb462ab8adbf51252eb11ce083",
        charles: "8ba415901810af78c8ae75239b0c61fc54f09850a4c32f4acd206308",
        hallow: "0a05e7b75baf1bba6754baf03536f8e9f3ce798b84ad300428922bb4"
      };

      function isWalletConnected() {
        return !!(connectedWallet && connectedWallet.api);
      }

      function showProfileTab() {
        const tab = document.getElementById("profile-tab");
        if (tab) tab.style.display = "block";
      }

      function hideProfileDashboard() {
        const panel = document.getElementById("profile-dashboard");
        if (panel) panel.style.display = "none";
      }

      function showProfileDashboard() {
        const panel = document.getElementById("profile-dashboard");
        if (panel) {
          // ensure shop panel is closed when profile opens
          const shopPanel = document.getElementById("shop-panel");
          if (shopPanel) shopPanel.style.display = "none";
          panel.style.display = "block";
        }
      }

      function toggleProfileDashboard() {
        const panel = document.getElementById("profile-dashboard");
        if (!panel) return;
        const isVisible = panel.style.display === "block";
        if (isVisible) {
          hideProfileDashboard();
        } else {
          showProfileDashboard();
        }
      }

      function updateProfileDashboardUI() {
        const keyEl = document.getElementById("profile-wallet-key");
        const stakeEl = document.getElementById("profile-stake-address");
        const tabSub = document.getElementById("profile-tab-sub");
        const adaEl = document.getElementById("profile-ada-balance");
        const cocEl = document.getElementById("profile-coc-balance");
        const bisonEl = document.getElementById("profile-bison-status");
        const charlesEl = document.getElementById("profile-charles-status");
        const hallowEl = document.getElementById("profile-hallow-status");
        const packsRoot = document.getElementById("profile-dashboard-pack-counts");

        if (!connectedWallet || !connectedWallet.key) {
          if (keyEl) keyEl.textContent = "-";
          if (stakeEl) stakeEl.textContent = "-";
          if (tabSub) tabSub.textContent = "Awaiting wallet...";
          if (adaEl) adaEl.textContent = "-";
          if (cocEl) cocEl.textContent = "Coming soon";
          if (bisonEl) { bisonEl.textContent = "Checking..."; bisonEl.className = "profile-nft-status"; }
          if (charlesEl) { charlesEl.textContent = "Checking..."; charlesEl.className = "profile-nft-status"; }
          if (hallowEl) { hallowEl.textContent = "Checking..."; hallowEl.className = "profile-nft-status"; }
          if (packsRoot) packsRoot.innerHTML = "";
          return;
        }

        if (keyEl) keyEl.textContent = connectedWallet.key.toUpperCase();
        if (stakeEl) stakeEl.textContent = profileData.stakeAddress || "Syncing on-chain data...";
        if (tabSub) tabSub.textContent = profileData.stakeAddress
          ? "Profile synced"
          : "Syncing on-chain data...";
        if (adaEl) {
          adaEl.textContent =
            typeof profileData.adaBalance === "number"
              ? profileData.adaBalance.toLocaleString(undefined, { maximumFractionDigits: 6 }) + " ADA"
              : "Syncing...";
        }
        if (cocEl) {
          // $COC not live yet; show neutral placeholder but keep slot wired.
          cocEl.textContent =
            profileData.cocBalance != null
              ? String(profileData.cocBalance)
              : "Coming soon";
        }

        function setNftStatus(el, has) {
          if (!el) return;
          el.className = "profile-nft-status " + (has ? "yes" : "no");
          el.textContent = has ? "Holding" : "Not holding";
        }

        setNftStatus(bisonEl, profileData.nftHoldings.bison);
        setNftStatus(charlesEl, profileData.nftHoldings.charles);
        setNftStatus(hallowEl, profileData.nftHoldings.hallow);

        // Update pack counts block (local pack.js state)
        if (typeof renderProfilePackCounts === "function") {
          renderProfilePackCounts();
        }
      }

      function setProfileError(msg) {
        const el = document.getElementById("profile-error");
        if (el) el.textContent = msg || "";
      }

      // Fetch stake address and policy holdings via Blockfrost
      async function fetchProfileOnChain(api) {
        try {
          setProfileError("");
          profileData.stakeAddress = null;
          profileData.adaBalance = null;
          profileData.cocBalance = null;
          profileData.nftHoldings = { bison: false, charles: false, hallow: false };
          updateProfileDashboardUI();

          // Get used or unused address from wallet
          const used = (await api.getUsedAddresses()) || [];
          const unused = (await api.getUnusedAddresses()) || [];
          const addrs = used.length > 0 ? used : unused;
          if (!addrs.length) {
            setProfileError("Unable to read wallet address from CIP-30 API.");
            updateProfileDashboardUI();
            return;
          }

          // CIP-30 returns base16 addresses; Blockfrost /addresses expects bech32.
          // Decode hex -> bytes -> encode bech32 with hrp based on networkId.
          const hex = addrs[0];
          let bech32Addr = null;
          try {
            const netId = await api.getNetworkId(); // 1 mainnet, 0 testnet/preprod/etc.
            const hrp = netId === 1 ? "addr" : "addr_test";

            function hexToBytes(h) {
              const out = new Uint8Array(h.length / 2);
              for (let i = 0; i < out.length; i++) {
                out[i] = parseInt(h.substr(i * 2, 2), 16);
              }
              return out;
            }

            // Minimal bech32 implementation (from reference, adapted inline)
            (function () {
              const CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
              function polymod(values) {
                const GENERATORS = [0x3b6a57b2,0x26508e6d,0x1ea119fa,0x3d4233dd,0x2a1462b3];
                let chk = 1;
                for (let p = 0; p < values.length; ++p) {
                  const top = chk >>> 25;
                  chk = ((chk & 0x1ffffff) << 5) ^ values[p];
                  for (let i = 0; i < 5; ++i) {
                    if ((top >>> i) & 1) {
                      chk ^= GENERATORS[i];
                    }
                  }
                }
                return chk;
              }
              function hrpExpand(hrp) {
                const ret = [];
                for (let i = 0; i < hrp.length; ++i) {
                  ret.push(hrp.charCodeAt(i) >>> 5);
                }
                ret.push(0);
                for (let i = 0; i < hrp.length; ++i) {
                  ret.push(hrp.charCodeAt(i) & 31);
                }
                return ret;
              }
              function createChecksum(hrp, data) {
                const values = hrpExpand(hrp).concat(data).concat([0,0,0,0,0,0]);
                const mod = polymod(values) ^ 1;
                const ret = [];
                for (let p = 0; p < 6; ++p) {
                  ret.push((mod >>> (5 * (5 - p))) & 31);
                }
                return ret;
              }
              function encodeBech32(hrp, data) {
                const combined = data.concat(createChecksum(hrp, data));
                let s = hrp + "1";
                for (let i = 0; i < combined.length; ++i) {
                  s += CHARSET.charAt(combined[i]);
                }
                return s;
              }
              function convertBits(data, fromBits, toBits, pad) {
                let acc = 0;
                let bits = 0;
                const ret = [];
                const maxv = (1 << toBits) - 1;
                for (let p = 0; p < data.length; ++p) {
                  const value = data[p];
                  if (value < 0 || (value >> fromBits) !== 0) {
                    return null;
                  }
                  acc = (acc << fromBits) | value;
                  bits += fromBits;
                  while (bits >= toBits) {
                    bits -= toBits;
                    ret.push((acc >> bits) & maxv);
                  }
                }
                if (pad) {
                  if (bits > 0) {
                    ret.push((acc << (toBits - bits)) & maxv);
                  }
                } else if (bits >= fromBits || ((acc << (toBits - bits)) & maxv)) {
                  return null;
                }
                return ret;
              }
              window.__adaarcana_bech32 = { encodeBech32, convertBits };
            })();

            const { encodeBech32, convertBits } = window.__adaarcana_bech32;
            const bytes = hexToBytes(hex);
            const data5 = convertBits(Array.from(bytes), 8, 5, true);
            if (!data5) throw new Error("convertBits failed");
            bech32Addr = encodeBech32(hrp, data5);
          } catch (e) {
            console.error("Bech32 address encoding failed", e);
            setProfileError("Failed to normalize wallet address for on-chain lookup.");
            updateProfileDashboardUI();
            return;
          }

          // Resolve to stake address using normalized bech32 address and fetch ADA balance
          const addrResp = await fetch(
            `${BLOCKFROST_BASE}/addresses/${bech32Addr}`,
            {
              headers: {
                project_id: BLOCKFROST_API_KEY
              }
            }
          );
          if (!addrResp.ok) {
            setProfileError("Address lookup failed.");
            updateProfileDashboardUI();
            return;
          }
          const addrJson = await addrResp.json();

          // Direct address lovelace balance -> ADA
          try {
            const lovelace =
              Array.isArray(addrJson.amount)
                ? Number(
                    (addrJson.amount.find(a => a.unit === "lovelace") || {}).quantity || 0
                  )
                : 0;
            if (!Number.isNaN(lovelace)) {
              profileData.adaBalance = lovelace / 1_000_000;
            }
          } catch {
            profileData.adaBalance = null;
          }

          const stakeAddr = addrJson.stake_address || null;
          profileData.stakeAddress = stakeAddr;
          updateProfileDashboardUI();

          // Map connected wallet -> Supabase user (stores base addr + stake addr)
          currentUserId = await ensureUser({
            walletKey: connectedWallet?.key || "UNKNOWN",
            walletAddr: bech32Addr,
            stakeAddress: stakeAddr || null
          });

          if (!stakeAddr) {
            setProfileError("No stake address found for this wallet (no delegations).");
            return;
          }

          // Fetch all account assets via stake address using correct Blockfrost endpoint.
          // Docs: https://docs.blockfrost.io/#tag/Cardano-Accounts
          async function fetchAllAccountAssets(stakeAddress) {
            const all = [];
            let page = 1;
            const count = 100;

            // Hard timeout (ms) so we don't stall the UI forever.
            const MAX_TIME_MS = 5000;
            const start = Date.now();

            while (true) {
              if (Date.now() - start > MAX_TIME_MS) {
                console.warn("Asset fetch timeout reached, proceeding with partial data.");
                break;
              }

              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 3000);

              try {
                const resp = await fetch(
                  `${BLOCKFROST_BASE}/accounts/${stakeAddress}/addresses/assets?page=${page}&count=${count}`,
                  {
                    headers: { project_id: BLOCKFROST_API_KEY },
                    signal: controller.signal
                  }
                );
                clearTimeout(timeoutId);

                if (resp.status === 404) {
                  // No data for this stake yet.
                  break;
                }

                if (!resp.ok) {
                  console.warn("Non-OK assets response", resp.status);
                  break;
                }

                const data = await resp.json();
                if (!Array.isArray(data) || data.length === 0) break;

                all.push(...data);
                if (data.length < count) break;

                page++;
              } catch (err) {
                clearTimeout(timeoutId);
                if (err.name === "AbortError") {
                  console.warn("Assets request aborted (timeout), using partial data.");
                } else {
                  console.warn("Assets page fetch failed, using partial data.", err);
                }
                break;
              }
            }
            return all;
          }

          const assets = await fetchAllAccountAssets(stakeAddr);

          if (!assets.length) {
            // Show a concise, user-facing message instead of “Syncing...” hanging forever.
            setProfileError("On-chain data not fully available. If you hold NFTs, please retry.");
          }

          // Check policy IDs across all address-assets results
          const hasPolicy = policyId =>
            assets.some(a => (a.unit || "").toLowerCase().startsWith(policyId.toLowerCase()));

          profileData.nftHoldings = {
            bison: hasPolicy(POLICY_IDS.bison),
            charles: hasPolicy(POLICY_IDS.charles),
            hallow: hasPolicy(POLICY_IDS.hallow)
          };

          // Build detailed NFT collections for inventory tabs using Blockfrost asset metadata
          async function buildNftCollections(allAssets) {
            const collections = { bison: [], charles: [], hallow: [] };

            async function loadForPolicy(key, policyId) {
              const ownedUnits = allAssets
                .map(a => a.unit || "")
                .filter(u => u.toLowerCase().startsWith(policyId.toLowerCase()));

              for (const unit of ownedUnits) {
                try {
                  const res = await fetch(`${BLOCKFROST_BASE}/assets/${unit}`, {
                    headers: { project_id: BLOCKFROST_API_KEY }
                  });
                  if (!res.ok) continue;

                  const json = await res.json();
                  const md = json.onchain_metadata || {};
                  let image =
                    md.image ||
                    (Array.isArray(md.files) && md.files[0] && md.files[0].src) ||
                    "";

                  // Normalize common ipfs:// formats to an HTTP gateway URL so images render in browser
                  if (typeof image === "string") {
                    if (image.startsWith("ipfs://ipfs/")) {
                      image = image.replace("ipfs://", "https://ipfs.blockfrost.dev/");
                    } else if (image.startsWith("ipfs://")) {
                      image =
                        "https://ipfs.blockfrost.dev/ipfs/" +
                        image.replace("ipfs://", "");
                    }
                  }

                  collections[key].push({
                    unit: json.asset,
                    policy_id: json.policy_id,
                    assetName: json.asset_name,
                    onchain_metadata: md,
                    image
                  });
                } catch (e) {
                  console.warn("Failed to load asset metadata", unit, e);
                }
              }
            }

            await Promise.all([
              loadForPolicy("bison", POLICY_IDS.bison),
              loadForPolicy("charles", POLICY_IDS.charles),
              loadForPolicy("hallow", POLICY_IDS.hallow)
            ]);

            return collections;
          }

          // Populate NFT collections for inventory and expose globally
          profileData.nftCollections = await buildNftCollections(assets);
          window.profileData = profileData;

          updateProfileDashboardUI();
          Inventory.render();
        } catch (err) {
          console.error("Profile on-chain lookup error", err);
          setProfileError("Failed to sync on-chain profile.");
          updateProfileDashboardUI();
        }
      }

      // --- DATA LOADING ---
      let CARD_DATA = [];
      const CARD_DATA_READY = (async () => {
        try {
          const res = await fetch("cards.json");
          CARD_DATA = await res.json();
          console.log("Loaded cards.json", CARD_DATA.length);
        } catch (e) {
          console.error("Failed to load cards.json", e);
          CARD_DATA = [];
        }
      })();

      const texLoader = new THREE.TextureLoader();
      texLoader.crossOrigin = "anonymous";

      const RARITY_ORDER = [
        "celestials",
        "mythic",
        "legendary",
        "epic",
        "rare",
        "uncommon",
        "common"
      ];

      let PACKS = [];
      let SELECTED_PACK = null;
      let PENDING_PACK = null;
      const PACK_DATA_READY = (async () => {
        try {
          const res = await fetch("packs.json");
          PACKS = await res.json();
          SELECTED_PACK = PACKS.find(p => p.pack_id === 4) || PACKS[0] || null;
          console.log(
            "Loaded packs.json",
            PACKS.length,
            "default pack",
            SELECTED_PACK?.pack_name
          );
        } catch (e) {
          console.error("Failed to load packs.json", e);
          PACKS = [];
          SELECTED_PACK = null;
        }
      })();

      function normalizeRarityStr(s) {
        const r = (s || "common").toLowerCase();
        return r === "celestial" ? "celestials" : r;
      }

      let scene, camera, renderer, composer, raycaster, mouse;
      let packMesh;
      let cards = [];
      let isOpening = false;
      let packOpened = false;
      let revealedCount = 0;

      // --- INVENTORY & TOOLTIP ---
      let CARD_INDEX = {};
      CARD_DATA_READY.then(() => {
        try {
          CARD_INDEX = Object.fromEntries(CARD_DATA.map(c => [c.id, c]));
        } catch {
          CARD_INDEX = {};
        }
      });

      const HoverTooltip = (() => {
        let el;
        function ensure() {
          if (!el) {
            el = document.createElement("div");
            el.id = "hover-tooltip";
            el.style.position = "absolute";
            el.style.display = "none";
            el.style.maxWidth = "320px";
            el.style.padding = "8px 10px";
            el.style.border = "1px solid rgba(0,234,255,0.5)";
            el.style.background = "rgba(0,0,0,0.7)";
            el.style.backdropFilter = "blur(3px)";
            el.style.borderRadius = "8px";
            el.style.boxShadow = "0 0 12px rgba(0,234,255,0.25)";
            const ui = document.getElementById("ui-container");
            if (ui) ui.appendChild(el);
          }
        }
        function show(x, y, { name, rarity, description }) {
          ensure();
          const rKey = normalizeRarityStr(rarity || "common");
          el.innerHTML = `
            <div style="font-weight:700;font-size:14px">${name || "Unknown Card"}</div>
            <div style="font-size:11px;opacity:0.85">Rarity:
              <span style="color: var(--c-${rKey})">${(rKey || "COMMON").toUpperCase()}</span>
            </div>
            <div style="margin-top:6px;font-size:12px;line-height:1.35;opacity:0.95">
              ${description || ""}
            </div>
          `;
          const pad = 12;
          el.style.left = Math.min(window.innerWidth - 340, x + pad) + "px";
          el.style.top = Math.min(window.innerHeight - 180, y + pad) + "px";
          el.style.display = "block";
        }
        function hide() {
          if (el) el.style.display = "none";
        }
        return { show, hide };
      })();

      const Inventory = (() => {
        const KEY = "adaarcana.inventory.v1";
        let counts = {};

        // Temporary in-memory selection for 20-card exchange (demo only)
        const exchangeSelection = new Set();
        let exchangeMode = false;

        // Action tooltip state
        let actionTooltipEl = null;
        let actionTooltipTargetId = null;

        function ensureActionTooltip() {
          if (!actionTooltipEl) {
            actionTooltipEl = document.createElement("div");
            actionTooltipEl.id = "inv-action-tooltip";
            actionTooltipEl.innerHTML = `
              <button data-action="use-deck">Use to deck</button>
              <button data-action="exchange-pack">Exchange to Packs</button>
              <button data-action="consign">Consignment</button>
            `;
            document.body.appendChild(actionTooltipEl);

            actionTooltipEl.addEventListener("click", ev => {
              const btn = ev.target.closest("button[data-action]");
              if (!btn) return;
              const act = btn.getAttribute("data-action");
              const cardId = actionTooltipTargetId;
              if (!cardId) return;

              // Context-aware visibility & actions:
              const shopPanel = document.getElementById("shop-panel");
              const consignView = document.querySelector('[data-shop-view="consign"]');
              const isShopOpen = shopPanel && shopPanel.style.display === "block";
              const isConsignOpen =
                isShopOpen &&
                consignView &&
                consignView.style.display !== "none";

              if (act === "use-deck") {
                console.log("[DEMO] Use to deck clicked for card", cardId);
              } else if (act === "exchange-pack") {
                // Only valid when Shop is open (Packs view)
                if (!isShopOpen) {
                  console.log("[INFO] Exchange to Packs only available while Card Pack Shop is open.");
                } else {
                  if (!isExchangeMode()) setExchangeMode(true);
                  toggleExchangeCard(cardId);
                }
              } else if (act === "consign") {
                // Only valid when Consignment tab is active
                if (!isConsignOpen) {
                  console.log("[INFO] Consignment only available while Consignment tab is open.");
                } else {
                  console.log("[DEMO] Consignment clicked for card", cardId);
                }
              }

              hideActionTooltip();
            });

            // Hide when clicking elsewhere
            document.addEventListener("click", e => {
              if (!actionTooltipEl) return;
              if (
                actionTooltipEl.style.display === "block" &&
                !actionTooltipEl.contains(e.target)
              ) {
                hideActionTooltip();
              }
            });
          }
        }

        function showActionTooltip(cardId, x, y) {
          ensureActionTooltip();
          actionTooltipTargetId = cardId;

          const el = actionTooltipEl;
          const pad = 6;

          // Check context to toggle visibility of context-sensitive buttons
          const shopPanel = document.getElementById("shop-panel");
          const consignView = document.querySelector('[data-shop-view="consign"]');
          const isShopOpen = shopPanel && shopPanel.style.display === "block";
          const isConsignOpen =
            isShopOpen &&
            consignView &&
            consignView.style.display !== "none";

          const btnExchange = el.querySelector('button[data-action="exchange-pack"]');
          const btnConsign = el.querySelector('button[data-action="consign"]');

          if (btnExchange) {
            // Only show when shop (Packs UI) is open
            btnExchange.style.display = isShopOpen ? "block" : "none";
          }
          if (btnConsign) {
            // Only show when Consignment tab is open
            btnConsign.style.display = isConsignOpen ? "block" : "none";
          }

          // If only Use to deck is visible, keep tooltip but smaller; if nothing visible, abort.
          const anyVisible =
            Array.from(el.querySelectorAll("button")).some(b => b.style.display !== "none");
          if (!anyVisible) {
            hideActionTooltip();
            return;
          }

          // Position near click, clamped to viewport
          el.style.display = "block";
          const rect = el.getBoundingClientRect();
          const vw = window.innerWidth;
          const vh = window.innerHeight;

          let left = x + pad;
          let top = y + pad;
          if (left + rect.width > vw - 8) left = vw - rect.width - 8;
          if (top + rect.height > vh - 8) top = vh - rect.height - 8;

          el.style.left = left + "px";
          el.style.top = top + "px";
        }

        function hideActionTooltip() {
          if (actionTooltipEl) {
            actionTooltipEl.style.display = "none";
          }
          actionTooltipTargetId = null;
        }

        function isExchangeMode() {
          return exchangeMode;
        }

        function setExchangeMode(on) {
          exchangeMode = !!on;
          if (!exchangeMode) {
            exchangeSelection.clear();
          }
          renderExchangeModal();
        }

        function getExchangeSelectedIds() {
          return Array.from(exchangeSelection).map(id => Number(id));
        }

        function toggleExchangeCard(cardId) {
          if (!exchangeMode || !counts[cardId]) return;
          const key = String(cardId);
          if (exchangeSelection.has(key)) {
            exchangeSelection.delete(key);
          } else if (exchangeSelection.size < 20) {
            exchangeSelection.add(key);
          }
          renderExchangeModal();
          render(); // refresh inventory to apply/remove glow classes
        }

        function renderExchangeModal() {
          const modal = document.getElementById("exchange-modal");
          const list = document.getElementById("exchange-selected-list");
          const countLabel = document.getElementById("exchange-count-label");
          const confirmBtn = document.getElementById("exchange-confirm-btn");
          const closeBtn = document.getElementById("exchange-modal-close");
          if (!modal || !list || !countLabel || !confirmBtn || !closeBtn) return;

          // helper to sync glow state on inventory cards based on current selection
          function syncInventoryGlow() {
            const invGrid = document.getElementById("inv-grid");
            if (!invGrid) return;
            const selectedIds = new Set(getExchangeSelectedIds().map(id => String(id)));
            invGrid.querySelectorAll(".inv-item").forEach(item => {
              const img = item.querySelector("img");
              if (!img) {
                item.classList.remove("exchange-selected");
                return;
              }
              const match = img.getAttribute("src") && img.getAttribute("src").match(/cards\/(\d+)\.png$/);
              if (!match) {
                item.classList.remove("exchange-selected");
                return;
              }
              const cid = match[1];
              if (selectedIds.has(cid)) {
                item.classList.add("exchange-selected");
              } else {
                item.classList.remove("exchange-selected");
              }
            });
          }

          // Bind close once
          if (!closeBtn._bound) {
            closeBtn.addEventListener("click", () => {
              playUIClick();
              setExchangeMode(false);
            });
            closeBtn._bound = true;
          }

          const ids = getExchangeSelectedIds();

          if (!exchangeMode) {
            modal.style.display = "none";
            list.innerHTML =
              '<div style="opacity:0.7;">No cards selected. Click "Exchange 20 Cards" in the shop to begin.</div>';
            countLabel.textContent = "0 / 20 selected";
            confirmBtn.disabled = true;

            // clear any glow when leaving exchange mode
            const invGrid = document.getElementById("inv-grid");
            if (invGrid) {
              invGrid.querySelectorAll(".inv-item.exchange-selected").forEach(el => {
                el.classList.remove("exchange-selected");
              });
            }
            return;
          }

          modal.style.display = "block";

          if (!ids.length) {
            list.innerHTML =
              '<div style="opacity:0.7;">Click cards in your Backpack to add them to this exchange.</div>';
          } else {
            list.innerHTML = "";
            ids.forEach(id => {
              const meta =
                CARD_INDEX[id] ||
                CARD_DATA.find(c => c.id === id) ||
                {};
              const name = meta.name || `Card #${id}`;
              const row = document.createElement("div");
              row.className = "exchange-card-row";
              row.innerHTML = `
                <div class="exchange-card-name">${name}</div>
                <div class="exchange-card-remove" data-id="${id}">Remove</div>
              `;
              list.appendChild(row);
            });

            list.querySelectorAll(".exchange-card-remove").forEach(el => {
              if (el._bound) return;
              el.addEventListener("click", ev => {
                ev.stopPropagation();
                const cid = String(el.getAttribute("data-id"));
                exchangeSelection.delete(cid);
                renderExchangeModal();
              });
              el._bound = true;
            });
          }

          countLabel.textContent = `${ids.length} / 20 selected`;
          confirmBtn.disabled = ids.length !== 20;

          // update glow on inventory cards while modal is active
          syncInventoryGlow();

          if (!confirmBtn._bound) {
            confirmBtn.addEventListener("click", async () => {
              if (confirmBtn.disabled) return;
              const selectedIds = getExchangeSelectedIds();
              try {
                // Remove 1 count for each selected card from local inventory
                selectedIds.forEach(id => {
                  if (counts[id] > 0) {
                    counts[id] -= 1;
                    if (counts[id] <= 0) {
                      delete counts[id];
                    }
                  }
                });
                save();

                // Grant one random pack (local pack balance) as reward
                try {
                  const packModule = await import("./pack.js");
                  const packTypes = packModule.PACK_TYPES || (window.PACK_TYPES || {});
                  const addPacksFn = packModule.addPacks || window.addPacks;

                  const packTypeValues = Object.values(packTypes || {});
                  if (packTypeValues.length && typeof addPacksFn === "function") {
                    const awarded = packTypeValues[Math.floor(Math.random() * packTypeValues.length)];
                    addPacksFn(awarded, 1);
                    if (typeof packModule.renderProfilePackCounts === "function") {
                      packModule.renderProfilePackCounts();
                    } else if (typeof window.renderProfilePackCounts === "function") {
                      window.renderProfilePackCounts();
                    }
                    console.log("Exchange complete. Awarded pack:", awarded, "for cards:", selectedIds);

                    // Show result modal for 20-card exchange
                    showExchangeResultModal(
                      "20-Card Exchange",
                      [
                        "Your 20 selected cards have been exchanged.",
                        `You received 1 random pack: ${awarded}.`
                      ]
                    );
                  } else {
                    console.warn("Pack exchange: PACK_TYPES/addPacks not available. Cards burned only.", {
                      packTypesAvailable: !!packTypeValues.length,
                      hasAddPacks: typeof addPacksFn === "function"
                    });
                    showExchangeResultModal(
                      "20-Card Exchange",
                      [
                        "Your 20 selected cards were processed, but packs could not be credited locally.",
                        "Verify pack.js configuration for PACK_TYPES/addPacks."
                      ]
                    );
                  }
                } catch (e) {
                  console.error("Pack exchange: failed to credit random pack:", e);
                  showExchangeResultModal(
                    "20-Card Exchange Failed",
                    [
                      "An error occurred while crediting your pack.",
                      "Check console/logs for more details."
                    ]
                  );
                }
              } catch (err) {
                console.error("Pack exchange error:", err);
                showExchangeResultModal(
                  "20-Card Exchange Failed",
                  ["Unexpected error while burning selected cards."]
                );
              }

              // Reset selection and UI
              setExchangeMode(false);
              render(); // refresh inventory (also clears glows via renderExchangeModal)
            });
            confirmBtn._bound = true;
          }
        }

        // Inventory:
        // - "Cards" tab: uses local pack-opened cards.json entries from localStorage.
        // - NFT tabs (Bison / Charles / Hallow): use on-chain collections discovered via Blockfrost / profileData.
        //   Those NFTs are NOT stored in this local counts map and are read from profileData.nftCollections.

        function filterByTab(entriesArr, tab) {
          // Only applies to the Cards tab (pack-opened cards).
          if (!tab || tab !== "cards") return [];
          return entriesArr;
        }

        function load() {
          try {
            const raw = localStorage.getItem(KEY);
            counts = raw ? JSON.parse(raw) : {};
          } catch {
            counts = {};
          }
        }
        function save() {
          try {
            localStorage.setItem(KEY, JSON.stringify(counts));
          } catch {}
        }
        function add(id, n = 1) {
          counts[id] = (counts[id] || 0) + n;
          save();
        }
        function addMany(ids) {
          ids.forEach(id => add(id, 1));
        }
        function entries() {
          return Object.entries(counts).map(([id, qty]) => ({
            id: Number(id),
            qty
          }));
        }
        function total() {
          return Object.values(counts).reduce((a, b) => a + b, 0);
        }
        function render() {
          const panel = document.getElementById("inventory-panel");
          const grid = document.getElementById("inv-grid");
          const btn = document.getElementById("backpack-btn");
          if (btn) btn.title = `Inventory (${total()})`;
          if (!panel || !grid) return;
          grid.innerHTML = "";

          const activeTabEl = panel.querySelector(".inv-tab.active");
          const activeTab = activeTabEl ? activeTabEl.getAttribute("data-tab") || "cards" : "cards";

          // 1) CARDS TAB: show local pack-opened cards.json inventory (no confusion with NFTs)
          if (activeTab === "cards") {
            filterByTab(entries(), activeTab)
              .sort((a, b) => a.id - b.id)
              .forEach(({ id, qty }) => {
                const meta =
                  CARD_INDEX[id] ||
                  CARD_DATA.find(c => c.id === id) ||
                  {};
                const displayName = meta.name || `Card #${id}`;
                const rarity = meta.rarity || "common";
                const description = meta.description || "";

                const item = document.createElement("div");
                item.className = "inv-item";
                item.innerHTML = `
                  <img src="cards/${id}.png" alt="${displayName}"
                    onerror="this.onerror=null; this.src='${meta.image || `cards/${id}.png`}'" />
                  <div class="inv-count-badge">${qty}</div>
                `;

                item.addEventListener("mousemove", ev => {
                  HoverTooltip.show(ev.clientX, ev.clientY, {
                    name: displayName,
                    rarity,
                    description
                  });
                });
                item.addEventListener("mouseleave", () =>
                  HoverTooltip.hide()
                );
                item.addEventListener("click", ev => {
                  ev.stopPropagation();
                  HoverTooltip.hide();
                  // In exchange mode, clicking toggles selection for exchange
                  if (isExchangeMode()) {
                    toggleExchangeCard(id);
                  }
                  // Always show action tooltip for this card
                  showActionTooltip(id, ev.clientX, ev.clientY);
                });
                grid.appendChild(item);
              });
          }

          // 2) NFT TABS: show only on-chain metadata + image for the three NFT collections
          // Requires window.profileData.nftCollections to be populated externally as:
          // { bison: [...], charles: [...], hallow: [...] }
          const nftCollections =
            (window.profileData && window.profileData.nftCollections) || {};
          const selectedNfts =
            activeTab === "bison"
              ? nftCollections.bison || []
              : activeTab === "charles"
              ? nftCollections.charles || []
              : activeTab === "hallow"
              ? nftCollections.hallow || []
              : [];

          if (activeTab !== "cards") {
            grid.innerHTML = "";
            selectedNfts.forEach(nft => {
              const md = nft.onchain_metadata || {};
              const name =
                md.name || nft.assetName || "NFT";
              const image =
                nft.image || md.image || "";
              const description = md.description || "";
              // Only show trait-like metadata (e.g. rarity, class, role, etc.) to keep display focused
              const traitsEntries = Object.entries(md).filter(
                ([k]) => {
                  const key = k.toLowerCase();
                  if (key === "name" || key === "image" || key === "description") return false;
                  // keep common trait/rarity fields
                  if (key.includes("rarity") || key === "class" || key === "type" || key === "role" || key === "faction") {
                    return true;
                  }
                  // hide noisy technical fields; adjust as needed for your policy metadata
                  if (key === "mediaType" || key === "mediatype" || key === "files" || key === "sha256") return false;
                  // default: hide to avoid clutter
                  return false;
                }
              );

              const item = document.createElement("div");
              item.className = "inv-item";
              item.innerHTML = `
                <img src="${image}" alt="${name}"
                     onerror="this.onerror=null; this.style.display='none';" />
                <div style="
                  padding:4px 5px 6px;
                  font-size:8px;
                  line-height:1.4;
                  background:rgba(0,0,0,0.9);
                  border-top:1px solid rgba(212,175,55,0.35);
                ">
                  <div style="font-weight:700;text-transform:uppercase;color:#ffd700;margin-bottom:2px;">
                    ${name}
                  </div>
                  ${
                    description
                      ? `<div style="opacity:0.9;margin-bottom:3px;">${description}</div>`
                      : ""
                  }
                  ${
                    traitsEntries.length
                      ? traitsEntries
                          .slice(0, 8)
                          .map(
                            ([k, v]) =>
                              `<div><span style="opacity:0.7">${k}:</span> ${String(
                                v
                              )}</div>`
                          )
                          .join("")
                      : `<div style="opacity:0.7">On-chain metadata loaded.</div>`
                  }
                </div>
              `;

              item.addEventListener("mousemove", ev => {
                HoverTooltip.show(ev.clientX, ev.clientY, {
                  name,
                  rarity: "nft",
                  description:
                    description || "On-chain metadata view."
                });
              });
              item.addEventListener("mouseleave", () => {
                HoverTooltip.hide();
              });

              grid.appendChild(item);
            });
          }

          // Bind tab clicks once
          const tabs = panel.querySelectorAll(".inv-tab");
          tabs.forEach(tabEl => {
            if (tabEl._bound) return;
            tabEl.addEventListener("click", () => {
              tabs.forEach(t => t.classList.remove("active"));
              tabEl.classList.add("active");
              render(); // re-render with new filter
            });
            tabEl._bound = true;
          });

          const closeBtn = panel.querySelector(".inv-close");
          if (closeBtn && !closeBtn._bound) {
            closeBtn.addEventListener("click", () =>
              hidePanel()
            );
            closeBtn._bound = true;
          }
          // keep exchange modal in sync when rendering
          renderExchangeModal();
        }
        function showPanel() {
          const panel = document.getElementById("inventory-panel");
          if (panel) {
            panel.style.display = "block";
            render();
          }
        }
        function hidePanel() {
          const panel = document.getElementById("inventory-panel");
          if (panel) panel.style.display = "none";
          HoverTooltip.hide();
          // leaving inventory cancels exchange mode and removes any glows
          setExchangeMode(false);
        }
        function togglePanel() {
          const panel = document.getElementById("inventory-panel");
          if (!panel) return;
          if (
            panel.style.display === "none" ||
            panel.style.display === ""
          ) {
            showPanel();
          } else {
            hidePanel();
          }
        }
        load();

        // Expose Inventory on window so other handlers can call helpers
        const Inventory = {
          add,
          addMany,
          render,
          showPanel,
          hidePanel,
          togglePanel,
          beginExchangeMode: () => setExchangeMode(true),

          // Ensure we have a local mirror of on-chain NFT collections with "used" flags
          ensureLocalNftInventory() {
            if (!window.profileData || !window.profileData.nftCollections) return;

            if (!window.localNftInventory) {
              window.localNftInventory = { bison: [], charles: [], hallow: [] };
            }

            ["bison", "charles", "hallow"].forEach(key => {
              const src = window.profileData.nftCollections[key] || [];
              const dst = window.localNftInventory[key];
              src.forEach(n => {
                if (!dst.find(x => x.unit === n.unit)) {
                  dst.push({
                    unit: n.unit,
                    name:
                      (n.onchain_metadata && n.onchain_metadata.name) ||
                      n.assetName ||
                      "NFT",
                    used: false
                  });
                }
              });
            });
          },

          // Mark one NFT of the specified type as used (off-chain demo only)
          markOneNftUsed(nftTypeKey) {
            this.ensureLocalNftInventory();
            const inv = window.localNftInventory || {};
            const list = inv[nftTypeKey] || [];
            const nft = list.find(x => !x.used);
            if (!nft) return null;
            nft.used = true;
            return nft;
          },

          // NFT -> Packs exchange helper wired to Supabase backend (live-style)
          // Backend must:
          //  - validate ownership
          //  - burn/lock NFT
          //  - mint/credit packs and mark NFT used in DB
          awardRandomPacksForNft: async (nftTypeKey) => {
            try {
              if (!currentUserId) {
                showExchangeResultModal(
                  "NFT Exchange",
                  [
                    "Wallet profile not linked to database.",
                    "Reconnect wallet so the user can be created before NFT exchange."
                  ]
                );
                return;
              }

              if (!connectedWallet || !connectedWallet.api) {
                showExchangeResultModal(
                  "NFT Exchange",
                  [
                    "Connect your wallet before exchanging NFTs for packs."
                  ]
                );
                return;
              }

              // Ensure local NFT inventory mirror exists
              Inventory.ensureLocalNftInventory();

              const res = await fetch("https://jralfkzdfajroshkpdln.supabase.co/functions/v1/exchange-nft", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  apikey: "${SUPABASE_ANON_KEY}"
                },
                body: JSON.stringify({
                  userId: currentUserId,
                  nftType: nftTypeKey,
                  stakeAddress: profileData.stakeAddress || null
                })
              });

              const data = await res.json().catch(() => ({}));

              if (!res.ok || !data.success) {
                showExchangeResultModal(
                  "NFT Exchange Failed",
                  [data.message || "Backend rejected NFT exchange request."]
                );
                return;
              }

              // Mark NFT as used in localNftInventory for visual feedback
              if (data.usedNftUnit && window.localNftInventory && window.localNftInventory[nftTypeKey]) {
                const list = window.localNftInventory[nftTypeKey];
                const target = list.find(x => x.unit === data.usedNftUnit);
                if (target) target.used = true;
              }

              // Update pack balances if backend returned them
              try {
                const packModule = await import("./pack.js");
                if (data.packBalances && typeof packModule.syncPackBalances === "function") {
                  packModule.syncPackBalances(data.packBalances);
                }
                if (typeof packModule.renderProfilePackCounts === "function") {
                  packModule.renderProfilePackCounts();
                } else if (typeof window.renderProfilePackCounts === "function") {
                  window.renderProfilePackCounts();
                }
              } catch (e) {
                console.warn("Failed to sync pack balances after NFT exchange", e);
              }

              // Re-render inventory so used NFT appears red/USED
              Inventory.render();

              const awardedLines = Array.isArray(data.awardedPacks)
                ? data.awardedPacks.map((p, i) => `Pack ${i + 1}: ${p}`)
                : [];

              showExchangeResultModal(
                data.title || "NFT Exchange Successful",
                [
                  `1 ${nftTypeKey.toUpperCase()} NFT consumed: ${String(data.usedNftUnit || "").slice(0, 8)}...`,
                  ...(awardedLines.length ? awardedLines : ["Packs credited to your account."])
                ]
              );
            } catch (err) {
              console.error("NFT -> pack exchange error", err);
              showExchangeResultModal(
                "NFT Exchange Failed",
                [
                  "An unexpected error occurred during NFT exchange.",
                  "Check backend / logs for more details."
                ]
              );
            }
          }
        };

        window.Inventory = Inventory;
        return Inventory;
      })();

      function playUIClick() {
        try {
          if (!window.__adaAudioCtx) {
            window.__adaAudioCtx =
              new (window.AudioContext ||
                window.webkitAudioContext)();
          }
          const ctx = window.__adaAudioCtx;
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = "sine";
          o.frequency.setValueAtTime(880, ctx.currentTime);
          g.gain.setValueAtTime(0.12, ctx.currentTime);
          g.gain.exponentialRampToValueAtTime(
            0.0001,
            ctx.currentTime + 0.08
          );
          o.connect(g);
          g.connect(ctx.destination);
          o.start();
          o.stop(ctx.currentTime + 0.09);
        } catch {}
      }

      // --- EXCHANGE RESULT MODAL HELPER ---
      function showExchangeResultModal(title, lines) {
        const backdrop = document.getElementById("exchange-result-backdrop");
        const modal = document.getElementById("exchange-result-modal");
        const titleEl = document.getElementById("exchange-result-title");
        const bodyEl = document.getElementById("exchange-result-body");
        const closeBtn = document.getElementById("exchange-result-close");
        if (!backdrop || !modal || !titleEl || !bodyEl || !closeBtn) {
          console.warn("Exchange result modal elements missing.");
          return;
        }

        titleEl.textContent = title || "Exchange Result";
        if (Array.isArray(lines) && lines.length) {
          bodyEl.innerHTML = lines.map(l => `<div>${l}</div>`).join("");
        } else if (typeof lines === "string") {
          bodyEl.textContent = lines;
        } else {
          bodyEl.textContent = "";
        }

        backdrop.style.display = "flex";

        if (!closeBtn._bound) {
          closeBtn.addEventListener("click", () => {
            backdrop.style.display = "none";
          });
          closeBtn._bound = true;
        }

        if (!backdrop._bound) {
          backdrop.addEventListener("click", e => {
            if (e.target === backdrop) {
              backdrop.style.display = "none";
            }
          });
          backdrop._bound = true;
        }
      }

      // --- INIT ---
      startPreloader();
      init();
      animate();

      function init() {
        const loadingEl = document.getElementById("loading");
        if (loadingEl) loadingEl.remove();

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);
        scene.background = new THREE.Color(CONFIG.colors.bg);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(
          window.innerWidth,
          window.innerHeight
        );
        renderer.setPixelRatio(
          Math.min(window.devicePixelRatio, 2)
        );
        renderer.toneMapping =
          THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(
            window.innerWidth,
            window.innerHeight
          ),
          1.5,
          0.4,
          0.85
        );
        bloomPass.threshold = 0.35;
        bloomPass.strength = 0.6;
        bloomPass.radius = 0.3;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        composer.addPass(new OutputPass());

        const ambientLight = new THREE.AmbientLight(
          0xffffff,
          0.5
        );
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(
          0xffffff,
          2
        );
        dirLight.position.set(5, 10, 7.5);
        scene.add(dirLight);

        const gridHelper = new THREE.GridHelper(
          50,
          50,
          CONFIG.colors.rare,
          CONFIG.colors.grid
        );
        gridHelper.position.y = -2;
        scene.add(gridHelper);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        createPack();

        PACK_DATA_READY.then(() => {
          renderPackSelection();
          const instr = document.getElementById("instruction");
          if (instr)
            instr.textContent =
              "Connect your wallet to begin";
        });

        window.addEventListener(
          "resize",
          onWindowResize
        );
        window.addEventListener("click", onClick);
        window.addEventListener(
          "mousemove",
          onMouseMove
        );

        const bpBtn =
          document.getElementById("backpack-btn");
        if (bpBtn && !bpBtn._bound) {
          bpBtn.addEventListener("click", () => {
            playUIClick();
            Inventory.togglePanel();
          });
          bpBtn._bound = true;
        }
        Inventory.render();

        setupWalletUI();

        // Profile Dashboard interactions
        const profileTab = document.getElementById("profile-tab");
        const profileClose = document.getElementById("profile-dashboard-close");
        if (profileTab && !profileTab._bound) {
          profileTab.addEventListener("click", () => {
            playUIClick();
            toggleProfileDashboard();
          });
          profileTab._bound = true;
        }
        if (profileClose && !profileClose._bound) {
          profileClose.addEventListener("click", () => {
            playUIClick();
            hideProfileDashboard();
          });
          profileClose._bound = true;
        }

        // NFT ➜ Pack exchange buttons (demo only; assumes off-chain/on-chain validation is handled elsewhere)
        function bindNftExchangeButton(btnId, nftKey) {
          const btn = document.getElementById(btnId);
          if (!btn || btn._bound) return;
          btn.addEventListener("click", async () => {
            playUIClick();

            // Show inline tooltip-style clarification on the button itself for UX
            btn.title = "Demo only. Actual NFT burn/lock + pack minting must be enforced on-chain or via backend.";

            if (!connectedWallet || !connectedWallet.api) {
              showExchangeResultModal(
                "NFT Exchange",
                [
                  "Connect your wallet before exchanging NFTs for packs.",
                  "This button is a demo trigger; production must validate ownership on-chain."
                ]
              );
              return;
            }

            // Ensure profileData has been populated
            const holdings = (window.profileData && window.profileData.nftHoldings) || {};
            if (!holdings[nftKey]) {
              showExchangeResultModal(
                "NFT Exchange",
                [
                  "Required NFT not detected for this connected wallet.",
                  "Ensure your Bison / Charles / Hallow NFT is held in this wallet."
                ]
              );
              return;
            }

            if (!window.Inventory || typeof window.Inventory.awardRandomPacksForNft !== "function") {
              showExchangeResultModal(
                "NFT Exchange Failed",
                [
                  "Inventory exchange helper is not available.",
                  "Verify that Inventory.awardRandomPacksForNft is defined."
                ]
              );
              return;
            }

            // IMPORTANT:
            // This is a front-end demo hook. You MUST enforce 1:1 NFT burn / locking and pack mint
            // in your backend or smart contract before calling this client helper in production.
            await window.Inventory.awardRandomPacksForNft(nftKey);
          });
          btn._bound = true;
        }

        bindNftExchangeButton("btn-exchange-bison-nft", "bison");
        bindNftExchangeButton("btn-exchange-charles-nft", "charles");
        bindNftExchangeButton("btn-exchange-hallow-nft", "hallow");

        // SHOP interactions
        const shopBtn = document.getElementById("shop-btn");
        const shopPanel = document.getElementById("shop-panel");
        const shopClose = document.getElementById("shop-close");
        const shopTabs = shopPanel ? shopPanel.querySelectorAll(".shop-tab") : [];
        const shopViews = shopPanel ? shopPanel.querySelectorAll("[data-shop-view]") : [];

        // Consignment submit handler: delegates to external integration hook
        const consignBtn = document.getElementById("btn-consign-submit");
        if (consignBtn && !consignBtn._bound) {
          consignBtn.addEventListener("click", () => {
            playUIClick();
            const qtyEl = document.getElementById("consign-qty");
            const modeEl = document.getElementById("consign-mode");
            const priceEl = document.getElementById("consign-price-or-packs");
            const payload = {
              quantity: qtyEl ? Number(qtyEl.value || 0) : 0,
              mode: modeEl ? modeEl.value : "sale",
              priceOrPacks: priceEl ? priceEl.value.trim() : ""
            };
            try {
              if (window.handleConsignmentSubmit && typeof window.handleConsignmentSubmit === "function") {
                window.handleConsignmentSubmit(payload);
              } else {
                console.log("Consignment submitted:", payload);
              }
            } catch (err) {
              console.error("Consignment handler error:", err);
            }
          });
          consignBtn._bound = true;
        }

        function showShopPanel() {
          if (!shopPanel) return;
          // ensure profile dashboard is closed when shop opens
          hideProfileDashboard();
          shopPanel.style.display = "block";
        }
        function hideShopPanel() {
          if (!shopPanel) return;
          shopPanel.style.display = "none";
        }

        if (shopBtn && !shopBtn._bound) {
          shopBtn.addEventListener("click", () => {
            playUIClick();
            showShopPanel();
          });
          shopBtn._bound = true;
        }

        if (shopClose && !shopClose._bound) {
          shopClose.addEventListener("click", () => {
            playUIClick();
            hideShopPanel();
          });
          shopClose._bound = true;
        }

        shopTabs.forEach(tabEl => {
          if (tabEl._bound) return;
          tabEl.addEventListener("click", () => {
            playUIClick();
            const target = tabEl.getAttribute("data-shop-tab");
            shopTabs.forEach(t => t.classList.remove("active"));
            tabEl.classList.add("active");
            shopViews.forEach(v => {
              const viewKey = v.getAttribute("data-shop-view");
              v.style.display = viewKey === target ? "block" : "none";
            });
          });
          tabEl._bound = true;
        });

        // Pack exchange: open inventory, enable exchange mode, and show selection modal
        const exchangeBtn = document.getElementById("btn-exchange-20cards-random-pack");
        if (exchangeBtn && !exchangeBtn._bound) {
          exchangeBtn.addEventListener("click", () => {
            playUIClick();
            // Open Backpack inventory in Cards tab
            const invPanel = document.getElementById("inventory-panel");
            const cardsTab = invPanel
              ? invPanel.querySelector('.inv-tab[data-tab="cards"]')
              : null;
            if (cardsTab) {
              invPanel.querySelectorAll(".inv-tab").forEach(t => t.classList.remove("active"));
              cardsTab.classList.add("active");
            }
            if (window.Inventory && typeof window.Inventory.showPanel === "function") {
              window.Inventory.showPanel();
            } else if (window.Inventory && typeof window.Inventory.togglePanel === "function") {
              // fallback: ensure visible
              const panel = document.getElementById("inventory-panel");
              if (!panel || panel.style.display === "none" || panel.style.display === "") {
                window.Inventory.togglePanel();
              }
            } else {
              const panel = document.getElementById("inventory-panel");
              if (panel) panel.style.display = "block";
            }

            // Enable exchange selection mode so card clicks populate the exchange modal
            if (window.Inventory && typeof window.Inventory.beginExchangeMode === "function") {
              window.Inventory.beginExchangeMode();
            }

            // Show a temporary instruction message
            const instr = document.getElementById("instruction");
            if (instr) {
              const prev = instr.getAttribute("data-prev") || instr.textContent;
              instr.setAttribute("data-prev", prev);
              instr.textContent = "Select 20 cards in your Backpack to exchange for a random premium pack.";
              setTimeout(() => {
                const restore = instr.getAttribute("data-prev");
                if (restore) instr.textContent = restore;
              }, 4000);
            }

            // NOTE:
            // Actual selection and 20-card burn/mint logic should be implemented in your inventory/pack.js layer.
          });
          exchangeBtn._bound = true;
        }
      }

      // --- PRELOADER ---
      function startPreloader() {
        const pre = document.getElementById("preloader");
        if (!pre) return;
        const fill = document.getElementById("preload-bar-fill");
        const cntEl = document.getElementById("preload-count");
        const totEl = document.getElementById("preload-total");
        const pctEl = document.getElementById("preload-percent");

        Promise.allSettled([CARD_DATA_READY, PACK_DATA_READY])
          .then(async () => {
            // Build asset list but cap how long we block on it,
            // so slow/missing images don't freeze the preloader.
            const urls = Array.from(new Set(getAllAssetUrls()));
            const total = urls.length || 1;
            if (totEl) totEl.textContent = String(urls.length);
            let done = 0;
            const update = () => {
              const pct = Math.min(
                100,
                Math.round((done / total) * 100)
              );
              if (fill) fill.style.width = pct + "%";
              if (cntEl) cntEl.textContent = String(done);
              if (pctEl) pctEl.textContent = pct + "%";
            };
            update();

            const MAX_WAIT_MS = 2500; // hard cap to avoid long stalls
            const preloadAll = Promise.all(
              urls.map(u =>
                preloadImage(u).finally(() => {
                  done++;
                  update();
                })
              )
            );

            // Wait until either all images attempted OR timeout.
            await Promise.race([
              preloadAll,
              new Promise(resolve => setTimeout(resolve, MAX_WAIT_MS))
            ]);

            setTimeout(() => pre.classList.add("hide"), 150);
            setTimeout(() => {
              pre.style.display = "none";
              showConnectWalletButton();
            }, 700);
          })
          .catch(() => {
            pre.classList.add("hide");
            setTimeout(() => {
              pre.style.display = "none";
              showConnectWalletButton();
            }, 700);
          });
      }

      function preloadImage(url) {
        return new Promise(resolve => {
          if (!url) return resolve();
          try {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = img.onerror = () => resolve();
            img.src = url;
          } catch {
            resolve();
          }
        });
      }

      function getAllAssetUrls() {
        const list = [];
        try {
          if (Array.isArray(PACKS)) {
            PACKS.forEach(p => {
              if (p && p.front_image) list.push(p.front_image);
              if (p && p.back_image) list.push(p.back_image);
            });
          }
        } catch {}
        try {
          if (Array.isArray(CARD_DATA)) {
            CARD_DATA.forEach(c => {
              if (c && c.id != null)
                list.push(`cards/${c.id}.png`);
              if (c && c.image) list.push(c.image);
            });
          }
        } catch {}
        list.push(
          "cards/back.png",
          "packfront.png",
          "packback.png",
          "packs/front.png",
          "packs/back.png",
          "favicon.png"
        );
        return list;
      }

      // --- WALLET UI / LOGIC ---
      function showConnectWalletButton() {
        const btn =
          document.getElementById(
            "connect-wallet-btn"
          );
        if (!btn) return;
        btn.style.display = "block";
        const instr =
          document.getElementById("instruction");
        if (instr)
          instr.textContent =
            "Connect your wallet to begin";
      }

      function setupWalletUI() {
        const btn = document.getElementById("connect-wallet-btn");
        const backdrop = document.getElementById("wallet-modal-backdrop");
        const closeBtn = document.getElementById("wallet-close-btn");
        const list = document.getElementById("wallet-list");
        const errorEl = document.getElementById("wallet-error");

        function openModal() {
          if (!backdrop) return;
          updateWalletDetection();
          backdrop.style.display = "flex";
          if (errorEl) errorEl.textContent = "";
        }

        function closeModal() {
          if (!backdrop) return;
          backdrop.style.display = "none";
        }

        if (btn && !btn._bound) {
          btn.addEventListener("click", () => {
            playUIClick();
            openModal();
          });
          btn._bound = true;
        }

        if (closeBtn && !closeBtn._bound) {
          closeBtn.addEventListener("click", () => {
            playUIClick();
            closeModal();
          });
          closeBtn._bound = true;
        }

        if (backdrop && !backdrop._boundClick) {
          backdrop.addEventListener("click", e => {
            // Clicking on dimmed area closes modal; clicks on inner modal are stopped via onclick on #wallet-modal
            if (e.target === backdrop) {
              closeModal();
            }
          });
          backdrop._boundClick = true;
        }

        if (list && !list._bound) {
          list.addEventListener("click", async e => {
            const item = e.target.closest(".wallet-item");
            if (!item) return;
            if (item.classList.contains("disabled"))
              return;

            const key =
              item.getAttribute(
                "data-wallet-key"
              );
            if (!key) return;

            try {
              await connectToWallet(key, item);
              closeModal();
            } catch (err) {
              console.error(err);
              if (errorEl)
                errorEl.textContent =
                  err?.message ||
                  "Failed to connect wallet.";
            }
          });
          list._bound = true;
        }
      }

      function updateWalletDetection() {
        const list =
          document.getElementById(
            "wallet-list"
          );
        if (!list) return;
        if (!window.cardano) {
          list
            .querySelectorAll(".wallet-item")
            .forEach(item => {
              item.classList.add("disabled");
              item.classList.remove("detected");
              const status =
                item.querySelector(
                  ".wallet-status"
                );
              if (status)
                status.textContent =
                  "Not detected";
            });
          return;
        }

        list
          .querySelectorAll(".wallet-item")
          .forEach(item => {
            const key =
              item.getAttribute(
                "data-wallet-key"
              );
            const status =
              item.querySelector(
                ".wallet-status"
              );
            if (!key || !status) return;
            const has = !!window.cardano[key];
            if (has) {
              item.classList.add("detected");
              item.classList.remove("disabled");
              status.textContent = "Available";
            } else {
              item.classList.remove("detected");
              item.classList.add("disabled");
              status.textContent = "Not detected";
            }
          });
      }

      async function connectToWallet(key, itemEl) {
        if (!window.cardano) {
          throw new Error(
            "No Cardano wallets detected in this browser."
          );
        }
        const wallet = window.cardano[key];
        if (!wallet || !wallet.enable) {
          throw new Error(
            "Selected wallet is not available."
          );
        }

        const api = await wallet.enable();

        let label = key.toUpperCase();
        try {
          const used =
            (await api.getUsedAddresses()) || [];
          const unused =
            (await api.getUnusedAddresses()) ||
            [];
          const addrs =
            used.length > 0 ? used : unused;
          if (addrs.length > 0) {
            const hex = addrs[0];
            label =
              key.toUpperCase() +
              ":" +
              hex.slice(0, 8) +
              "..." +
              hex.slice(-6);
          }
        } catch {
          label = key.toUpperCase();
        }

        connectedWallet = {
          key,
          name: key.toUpperCase(),
          api
        };

        if (itemEl) {
          itemEl.classList.add("detected");
        }

        const btn =
          document.getElementById(
            "connect-wallet-btn"
          );
        if (btn) btn.style.display = "none";

        const pill =
          document.getElementById(
            "connected-wallet-pill"
          );
        const pillLabel =
          document.getElementById(
            "connected-wallet-label"
          );
        if (pill && pillLabel) {
          pillLabel.textContent = label;
          pill.style.display = "block";
        }

        // Show and prime profile tab, then fetch on-chain profile
        showProfileTab();
        updateProfileDashboardUI();
        fetchProfileOnChain(api).catch(err => {
          console.error("Failed to fetch profile on-chain", err);
        });

        // Link wallet to Supabase immediately so NFT exchanges are not blocked by Blockfrost/profile failures
        (async () => {
          try {
            const used = (await api.getUsedAddresses()) || [];
            const unused = (await api.getUnusedAddresses()) || [];
            const addrs = used.length > 0 ? used : unused;
            if (!addrs.length) {
              console.warn("[supabase] No wallet address available for user creation.");
              return;
            }

            const hex = addrs[0];
            const netId = await api.getNetworkId();
            const hrp = netId === 1 ? "addr" : "addr_test";

            if (!window.__adaarcana_bech32) {
              console.warn("[supabase] bech32 helper missing; cannot link wallet to Supabase user.");
              return;
            }
            const { encodeBech32, convertBits } = window.__adaarcana_bech32;

            function hexToBytes(h) {
              const out = new Uint8Array(h.length / 2);
              for (let i = 0; i < out.length; i++) {
                out[i] = parseInt(h.substr(i * 2, 2), 16);
              }
              return out;
            }

            const bytes = hexToBytes(hex);
            const data5 = convertBits(Array.from(bytes), 8, 5, true);
            if (!data5) {
              console.warn("[supabase] convertBits failed; cannot link wallet to Supabase user.");
              return;
            }

            const bech32Addr = encodeBech32(hrp, data5);

            const userId = await ensureUser({
              walletKey: connectedWallet.key || "UNKNOWN",
              walletAddr: bech32Addr,
              // stakeAddress can be enriched later by fetchProfileOnChain
              stakeAddress: null
            });

            if (userId) {
              currentUserId = userId;
              console.log("[supabase] Linked wallet to Supabase user id", userId);
            } else {
              console.warn("[supabase] ensureUser returned no id; NFT exchange will be blocked until this succeeds.");
            }
          } catch (err) {
            console.error("[supabase] Failed to link wallet to Supabase user", err);
          }
        })();

        const instr =
          document.getElementById("instruction");
        if (instr)
          instr.textContent =
            "Select a pack to begin";

        applyPackTextures();
        console.log("Wallet connected:", key);
      }

      // --- VISUAL ASSETS ---
      function createFuturisticTexture(
        type,
        text,
        mainColorStr
      ) {
        const canvas =
          document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 768;
        const ctx =
          canvas.getContext("2d");

        const gradient =
          ctx.createLinearGradient(
            0,
            0,
            512,
            768
          );
        gradient.addColorStop(0, "#0a0a0a");
        gradient.addColorStop(1, "#1a1a2e");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 768);

        ctx.strokeStyle =
          mainColorStr + "44";
        ctx.lineWidth = 2;
        for (let i = 0; i < 512; i += 64) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, 768);
          ctx.stroke();
        }
        for (let i = 0; i < 768; i += 64) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(512, i);
          ctx.stroke();
        }

        ctx.strokeStyle = mainColorStr;
        ctx.lineWidth = 20;
        ctx.strokeRect(10, 10, 492, 748);

        if (type === "pack") {
          ctx.fillStyle = mainColorStr;
          ctx.font = "bold 60px Arial";
          ctx.textAlign = "center";
          ctx.fillText("ADA", 256, 350);
          ctx.fillText("ARCANA", 256, 420);
          ctx.strokeStyle = "white";
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(50, 384);
          ctx.lineTo(462, 384);
          ctx.stroke();
        } else {
          ctx.fillStyle = mainColorStr;
          ctx.font = "bold 40px Courier New";
          ctx.textAlign = "center";
          ctx.fillText(text, 256, 100);

          ctx.fillStyle = "#000000aa";
          ctx.fillRect(50, 150, 412, 400);

          ctx.strokeStyle =
            mainColorStr;
          ctx.lineWidth = 3;
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.arc(
              256,
              350,
              50 + i * 30,
              0,
              Math.PI *
                2 *
                Math.random()
            );
            ctx.stroke();
          }

          ctx.font = "30px Arial";
          ctx.fillStyle = "#ffffff";
          ctx.fillText(
            "FUTURISTIC ASSET",
            256,
            600
          );
        }

        const texture =
          new THREE.CanvasTexture(canvas);
        texture.anisotropy =
          renderer.capabilities.getMaxAnisotropy();
        return texture;
      }

      function createPack() {
        const geometry =
          new THREE.BoxGeometry(
            3,
            4.5,
            0.2
          );

        const sideMat =
          new THREE.MeshStandardMaterial({
            color: 0x222222,
            metalness: 0.6,
            roughness: 0.3
          });
        const frontMat =
          new THREE.MeshStandardMaterial({
            roughness: 0.4,
            metalness: 0.85,
            emissive: 0x000000,
            emissiveIntensity: 0
          });
        const backMat =
          new THREE.MeshStandardMaterial({
            roughness: 0.4,
            metalness: 0.85
          });

        const setTex = (
          mat,
          url,
          fallbackProcColor = "#00eaff"
        ) => {
          try {
            texLoader.load(
              url,
              tex => {
                if ("colorSpace" in tex)
                  tex.colorSpace =
                    THREE.SRGBColorSpace;
                tex.anisotropy =
                  renderer.capabilities.getMaxAnisotropy();
                mat.map = tex;
                mat.needsUpdate = true;
              },
              undefined,
              () => {
                const t =
                  createFuturisticTexture(
                    "pack",
                    "",
                    fallbackProcColor
                  );
                mat.map = t;
                mat.needsUpdate = true;
              }
            );
          } catch {
            const t =
              createFuturisticTexture(
                "pack",
                "",
                fallbackProcColor
              );
            mat.map = t;
            mat.needsUpdate = true;
          }
        };

        setTex(frontMat, "packfront.png");
        setTex(backMat, "packfront.png");

        const materials = [
          sideMat,
          sideMat,
          sideMat,
          sideMat,
          frontMat,
          backMat
        ];

        packMesh = new THREE.Mesh(
          geometry,
          materials
        );
        packMesh.name = "pack";
        scene.add(packMesh);

        gsap.to(packMesh.rotation, {
          y: Math.PI * 2,
          duration: 20,
          repeat: -1,
          ease: "none"
        });
        gsap.to(packMesh.position, {
          y: 0.5,
          duration: 2,
          yoyo: true,
          repeat: -1,
          ease: "sine.inOut"
        });
      }

      function applyPackTextures() {
        if (!packMesh || !SELECTED_PACK) return;
        try {
          texLoader.load(
            SELECTED_PACK.front_image,
            tex => {
              if ("colorSpace" in tex)
                tex.colorSpace =
                  THREE.SRGBColorSpace;
              tex.anisotropy =
                renderer.capabilities.getMaxAnisotropy();
              packMesh.material[4].map = tex;
              packMesh.material[4].needsUpdate = true;
            },
            undefined,
            () => {
              texLoader.load(
                "packfront.png",
                t => {
                  if ("colorSpace" in t)
                    t.colorSpace =
                      THREE.SRGBColorSpace;
                  t.anisotropy =
                    renderer.capabilities.getMaxAnisotropy();
                  packMesh.material[4].map = t;
                  packMesh.material[4].needsUpdate = true;
                },
                undefined,
                () => {
                  const t =
                    createFuturisticTexture(
                      "pack",
                      "",
                      "#00eaff"
                    );
                  packMesh.material[4].map = t;
                  packMesh.material[4].needsUpdate = true;
                }
              );
            }
          );
        } catch {}
        try {
          texLoader.load(
            SELECTED_PACK.front_image,
            tex => {
              if ("colorSpace" in tex)
                tex.colorSpace =
                  THREE.SRGBColorSpace;
              tex.anisotropy =
                renderer.capabilities.getMaxAnisotropy();
              packMesh.material[5].map = tex;
              packMesh.material[5].needsUpdate = true;
            },
            undefined,
            () => {
              texLoader.load(
                "packfront.png",
                t => {
                  if ("colorSpace" in t)
                    t.colorSpace =
                      THREE.SRGBColorSpace;
                  t.anisotropy =
                    renderer.capabilities.getMaxAnisotropy();
                  packMesh.material[5].map = t;
                  packMesh.material[5].needsUpdate = true;
                },
                undefined,
                () => {
                  const t =
                    createFuturisticTexture(
                      "pack",
                      "",
                      "#00eaff"
                    );
                  packMesh.material[5].map = t;
                  packMesh.material[5].needsUpdate = true;
                }
              );
            }
          );
        } catch {}
        packMesh.userData.selectedPackId =
          SELECTED_PACK.pack_id;
      }

      function formatRarityRates(weights) {
        if (!weights) return "";
        const toPct = v =>
          (Number(v || 0) * 100).toFixed(1) + "%";
        let html =
          '<div class="pack-rates">';
        for (const key of RARITY_ORDER) {
          const val = weights[key];
          if (val == null) continue;
          html += `
            <div class="rate-line">
              <span class="rate-label" style="color: var(--c-${key})">
                ${key.toUpperCase()}
              </span>
              <span class="rate-val">${toPct(
                val
              )}</span>
            </div>`;
        }
        html += "</div>";
        return html;
      }

      function renderPackSelection() {
        const grid =
          document.getElementById(
            "pack-grid"
          );
        const container =
          document.getElementById(
            "pack-selection"
          );
        const backdrop =
          document.getElementById(
            "modal-backdrop"
          );
        const confirmBtn =
          document.getElementById(
            "confirm-pack"
          );
        const cancelBtn =
          document.getElementById(
            "cancel-pack"
          );
        const titleEl =
          document.getElementById(
            "pack-modal-title"
          );

        if (
          !grid ||
          !container ||
          !PACKS ||
          PACKS.length === 0
        )
          return;
        grid.innerHTML = "";

        // Show user pack balances in modal title (local-state from pack.js)
        try {
          import("./pack.js").then(mod => {
            const getPackBalances = mod.getPackBalances || (window.getPackBalances || null);
            const PACK_TYPES = mod.PACK_TYPES || (window.PACK_TYPES || null);
            if (!getPackBalances || !PACK_TYPES || !titleEl) return;

            const b = getPackBalances();
            titleEl.innerHTML = `
              <div>Select a Pack</div>
              <div class="pack-balance-row">
                <div class="pack-badge">
                  <span class="label">Genesis Sigil</span>
                  <span class="count">${b[PACK_TYPES.GENESIS_SIGIL] || 0}</span>
                </div>
                <div class="pack-badge">
                  <span class="label">Crawju Forge</span>
                  <span class="count">${b[PACK_TYPES.CRAWJU_FORGE] || 0}</span>
                </div>
                <div class="pack-badge">
                  <span class="label">Bison Dominion</span>
                  <span class="count">${b[PACK_TYPES.BISON_DOMINION] || 0}</span>
                </div>
                <div class="pack-badge">
                  <span class="label">Celestial Chain</span>
                  <span class="count">${b[PACK_TYPES.CELESTIAL_CHAIN] || 0}</span>
                </div>
              </div>
            `;
          }).catch(() => {});
        } catch {}

        if (backdrop)
          backdrop.style.display =
            "block";
        container.style.display =
          "block";
        PENDING_PACK = null;
        if (confirmBtn)
          confirmBtn.disabled = true;

        PACKS.forEach(p => {
          const item =
            document.createElement("div");
          item.className = "pack-item";
          item.innerHTML = `
            <div class="pack-thumb">
              <img src="${p.front_image}" alt="${
            p.pack_name
          }"
                   onerror="this.onerror=null; this.src='packs/front.png';" />
            </div>
            <div class="pack-meta">
              <div class="pack-title">
                ${p.pack_name}
              </div>
              <div class="pack-desc">
                ${p.description}
              </div>
              ${formatRarityRates(
                p.rarity_weights
              )}
            </div>`;
          item.addEventListener("click", () => {
            Array.from(grid.children).forEach(
              child =>
                child.classList.remove(
                  "selected"
                )
            );
            item.classList.add("selected");
            PENDING_PACK = p;

            // If Genesis pack is selected while wallet is not connected, block proceeding and instruct user.
            try {
              const isGenesis =
                (PENDING_PACK.pack_name || "").toLowerCase().includes("genesis");
              if (isGenesis && !isWalletConnected()) {
                if (confirmBtn) confirmBtn.disabled = true;
                const instr = document.getElementById("instruction");
                if (instr) {
                  const prev = instr.getAttribute("data-prev") || instr.textContent;
                  instr.setAttribute("data-prev", prev);
                  instr.textContent = "Connect your wallet before selecting the Genesis pack.";
                }
                const btnConnect = document.getElementById("connect-wallet-btn");
                if (btnConnect && getComputedStyle(btnConnect).display === "none") {
                  btnConnect.style.display = "block";
                }
                return;
              }
            } catch (e) {
              console.warn("Genesis gating check failed", e);
            }

            if (confirmBtn)
              confirmBtn.disabled = false;
          });
          grid.appendChild(item);
        });

        if (confirmBtn && !confirmBtn._bound) {
          confirmBtn.addEventListener("click", () => {
            if (!PENDING_PACK) return;

            // Block confirming Genesis pack if wallet is not connected.
            try {
              const isGenesis =
                (PENDING_PACK.pack_name || "").toLowerCase().includes("genesis");
              if (isGenesis && !isWalletConnected()) {
                const instr = document.getElementById("instruction");
                if (instr) {
                  const prev = instr.getAttribute("data-prev") || instr.textContent;
                  instr.setAttribute("data-prev", prev);
                  instr.textContent = "Connect your wallet before confirming the Genesis pack.";
                }
                const btnConnect = document.getElementById("connect-wallet-btn");
                if (btnConnect && getComputedStyle(btnConnect).display === "none") {
                  btnConnect.style.display = "block";
                }
                return;
              }
            } catch (e) {
              console.warn("Genesis confirm gating failed", e);
            }

            SELECTED_PACK = PENDING_PACK;
            applyPackTextures();
            container.style.display =
              "none";
            if (backdrop)
              backdrop.style.display =
                "none";
            const instr =
              document.getElementById(
                "instruction"
              );
            if (instr)
              instr.textContent =
                "Click the pack to open";
          });
          confirmBtn._bound = true;
        }

        if (cancelBtn && !cancelBtn._bound) {
          cancelBtn.addEventListener("click", () => {
            Array.from(grid.children).forEach(
              child =>
                child.classList.remove(
                  "selected"
                )
            );
            PENDING_PACK = null;
            if (confirmBtn)
              confirmBtn.disabled = true;
          });
          cancelBtn._bound = true;
        }
      }

      function generateRarity() {
        if (
          SELECTED_PACK &&
          SELECTED_PACK.rarity_weights
        ) {
          const weights =
            SELECTED_PACK.rarity_weights;
          let r = Math.random();
          let cum = 0;
          for (const key of RARITY_ORDER) {
            const w = Number(
              weights[key] || 0
            );
            cum += w;
            if (r < cum) return key;
          }
          return "common";
        }
        const rand = Math.random();
        if (rand < 0.001) return "celestials";
        if (rand < 0.006) return "mythic";
        if (rand < 0.016) return "legendary";
        if (rand < 0.066) return "epic";
        if (rand < 0.266) return "rare";
        if (rand < 0.566) return "uncommon";
        return "common";
      }

      function createCard(cardData, index, total) {
        const raritySrc = (
          cardData.rarity || "Common"
        ).toLowerCase();
        const rarity =
          raritySrc === "celestial"
            ? "celestials"
            : raritySrc;

        let colorHex =
          CONFIG.colors.common;
        let glowIntensity = 0;
        switch (rarity) {
          case "celestials":
            colorHex =
              CONFIG.colors.celestials;
            glowIntensity = 1.5;
            break;
          case "mythic":
            colorHex =
              CONFIG.colors.mythic;
            glowIntensity = 1.0;
            break;
          case "legendary":
            colorHex =
              CONFIG.colors.legendary;
            glowIntensity = 0.8;
            break;
          case "epic":
            colorHex =
              CONFIG.colors.epic;
            glowIntensity = 0.5;
            break;
          case "rare":
            colorHex =
              CONFIG.colors.rare;
            glowIntensity = 0.18;
            break;
          case "uncommon":
            colorHex =
              CONFIG.colors.uncommon;
            glowIntensity = 0.08;
            break;
          default:
            colorHex =
              CONFIG.colors.common;
            glowIntensity = 0;
        }

        const geometry =
          new THREE.BoxGeometry(
            CONFIG.cardSize.w,
            CONFIG.cardSize.h,
            CONFIG.cardSize.d
          );

        const sideMat =
          new THREE.MeshStandardMaterial({
            color: 0x222222
          });
        const frontMat =
          new THREE.MeshStandardMaterial({
            roughness: 0.5,
            metalness: 0.7,
            emissive: colorHex,
            emissiveIntensity: 0
          });
        const backMat =
          new THREE.MeshStandardMaterial({
            roughness: 0.5,
            metalness: 0.7
          });

        const setFrontTex = tex => {
          if (tex && "colorSpace" in tex)
            tex.colorSpace =
              THREE.SRGBColorSpace;
          if (
            tex &&
            tex.anisotropy !== undefined
          ) {
            tex.anisotropy =
              renderer.capabilities.getMaxAnisotropy();
          }
          frontMat.map = tex;
          frontMat.needsUpdate = true;
        };
        const localFrontUrl =
          `cards/${cardData.id}.png`;
        const remoteFrontUrl =
          cardData.image;
        try {
          texLoader.load(
            localFrontUrl,
            t => setFrontTex(t),
            undefined,
            () => {
              try {
                texLoader.load(
                  remoteFrontUrl,
                  t2 =>
                    setFrontTex(t2),
                  undefined,
                  () => {
                    setFrontTex(
                      createFuturisticTexture(
                        "card",
                        (cardData.name ||
                          rarity).toUpperCase(),
                        "#ffffff"
                      )
                    );
                  }
                );
              } catch {
                setFrontTex(
                  createFuturisticTexture(
                    "card",
                    (cardData.name ||
                      rarity).toUpperCase(),
                    "#ffffff"
                  )
                );
              }
            }
          );
        } catch {
          setFrontTex(
            createFuturisticTexture(
              "card",
              (cardData.name ||
                rarity).toUpperCase(),
              "#ffffff"
            )
          );
        }

        const setBackTex = tex => {
          if (
            tex &&
            tex.anisotropy !== undefined
          ) {
            tex.anisotropy =
              renderer.capabilities.getMaxAnisotropy();
          }
          if (tex && "colorSpace" in tex) {
            tex.colorSpace =
              THREE.SRGBColorSpace;
          }
          backMat.map = tex;
          backMat.needsUpdate = true;
        };
        try {
          texLoader.load(
            cardData.back_image,
            tex => setBackTex(tex),
            undefined,
            () => {
              texLoader.load(
                "cards/back.png",
                tex =>
                  setBackTex(tex),
                undefined,
                () =>
                  setBackTex(
                    createFuturisticTexture(
                      "pack",
                      "",
                      "#ffffff"
                    )
                  )
              );
            }
          );
        } catch {
          texLoader.load(
            "cards/back.png",
            tex => setBackTex(tex),
            undefined,
            () =>
              setBackTex(
                createFuturisticTexture(
                  "pack",
                  "",
                  "#ffffff"
                )
              )
          );
        }

        const materials = [
          sideMat,
          sideMat,
          sideMat,
          sideMat,
          frontMat,
          backMat
        ];

        const card = new THREE.Mesh(
          geometry,
          materials
        );
        card.userData = {
          isCard: true,
          rarity,
          name: cardData.name,
          description: cardData.description,
          image: cardData.image,
          back_image: cardData.back_image,
          flipped: false,
          glowIntensity,
          basePos: new THREE.Vector3(
            (index - (total - 1) / 2) * 2.8,
            0,
            0
          ),
          index
        };
        return card;
      }

      function pickWeightedUnique(pool, n) {
        const weights = pool.map(c => {
          const s = (c.drop_rate || "0%")
            .toString()
            .trim();
          const num =
            parseFloat(
              s.replace("%", "")
            ) || 0;
          return Math.max(0, num);
        });
        const chosen = [];
        const used = new Set();
        for (let k = 0; k < n && k < pool.length; k++) {
          const total =
            weights.reduce(
              (a, b) => a + b,
              0
            );
          if (total <= 0) break;
          let r = Math.random() * total;
          let idx = 0;
          for (; idx < weights.length; idx++) {
            r -= weights[idx];
            if (r <= 0) break;
          }
          if (idx >= pool.length)
            idx = pool.length - 1;
          chosen.push(pool[idx]);
          used.add(idx);
          weights[idx] = 0;
        }
        for (let i = 0; chosen.length < n && i < pool.length; i++) {
          if (!used.has(i))
            chosen.push(pool[i]);
        }
        return chosen.slice(0, n);
      }

      function showCardInfo(card) {
        const ui =
          document.getElementById(
            "ui-container"
          );
        if (!ui) return;
        let panel =
          document.getElementById(
            "card-info-panel"
          );
        if (!panel) {
          panel =
            document.createElement(
              "div"
            );
          panel.id = "card-info-panel";
          panel.style.position =
            "absolute";
          panel.style.top = "8%";
          panel.style.left = "50%";
          panel.style.transform =
            "translateX(-50%)";
          panel.style.background =
            "rgba(0,0,0,0.6)";
          panel.style.backdropFilter =
            "blur(3px)";
          panel.style.border =
            "1px solid rgba(0,234,255,0.5)";
          panel.style.boxShadow =
            "0 0 12px rgba(0,234,255,0.25)";
          panel.style.borderRadius =
            "8px";
          panel.style.padding =
            "10px 14px";
          panel.style.pointerEvents =
            "none";
          panel.style.maxWidth = "78%";
          panel.style.textAlign =
            "center";
          ui.appendChild(panel);
        }
        const rarityKey =
          card.userData.rarity;
        const rarityText =
          rarityKey.toUpperCase();
        panel.innerHTML = `
          <div style="font-weight:700;font-size:18px;letter-spacing:0.5px">
            ${card.userData.name || "Unknown Card"}
          </div>
          <div style="font-size:12px;opacity:0.85;margin-top:2px">
            Rarity:
            <span style="color: var(--c-${rarityKey})">${rarityText}</span>
          </div>
          <div style="margin-top:6px;font-size:14px;line-height:1.35">
            ${card.userData.description || ""}
          </div>
        `;
      }

      function cleanupCards() {
        try {
          cards.forEach(c => {
            scene.remove(c);
            if (c.geometry?.dispose)
              c.geometry.dispose();
            if (Array.isArray(c.material)) {
              c.material.forEach(m => m?.dispose?.());
            } else {
              c.material?.dispose?.();
            }
          });
        } catch {}
        cards = [];
        document.body.style.cursor =
          "default";
        const info =
          document.getElementById(
            "card-info-panel"
          );
        if (info?.parentNode)
          info.parentNode.removeChild(info);
      }

      function hidePostOpenButtons() {
        const actions =
          document.getElementById(
            "post-open-actions"
          );
        if (actions)
          actions.style.display =
            "none";
      }

      function showPostOpenButtons() {
        const ui =
          document.getElementById(
            "ui-container"
          );
        if (!ui) return;
        let wrap =
          document.getElementById(
            "post-open-actions"
          );
        if (!wrap) {
          wrap =
            document.createElement(
              "div"
            );
          wrap.id = "post-open-actions";
          wrap.style.position =
            "absolute";
          wrap.style.bottom =
            "12%";
          wrap.style.left = "50%";
          wrap.style.transform =
            "translateX(-50%)";
          wrap.style.display = "flex";
          wrap.style.gap = "10px";
          wrap.style.pointerEvents =
            "auto";
          ui.appendChild(wrap);

          const openBtn =
            document.createElement(
              "button"
            );
          openBtn.id =
            "btn-open-another";
          openBtn.className =
            "btn btn-primary";
          openBtn.textContent =
            "Open Another Pack";
          openBtn.addEventListener(
            "click",
            () => {
              resetToInitialState(false);
            }
          );

          const menuBtn =
            document.createElement(
              "button"
            );
          menuBtn.id =
            "btn-back-menu";
          menuBtn.className =
            "btn";
          menuBtn.textContent =
            "Back to Menu";
          menuBtn.addEventListener(
            "click",
            () => {
              resetToInitialState(true);
            }
          );

          wrap.appendChild(openBtn);
          wrap.appendChild(menuBtn);
        }
        wrap.style.display = "flex";
      }

      function resetToInitialState(showMenu) {
        cleanupCards();
        hidePostOpenButtons();
        if (packMesh) {
          try {
            scene.remove(packMesh);
          } catch {}
          packMesh = null;
        }
        isOpening = false;
        packOpened = false;
        createPack();
        applyPackTextures();
        const instr =
          document.getElementById(
            "instruction"
          );
        if (showMenu) {
          if (instr)
            instr.textContent =
              "Select a pack to begin";
          renderPackSelection();
        } else {
          if (instr)
            instr.textContent =
              "Click the pack to open";
        }
      }

      // --- INTERACTION & ANIMATION ---
      // Show a styled alert + open wallet modal when trying to open pack without wallet
      function showConnectWalletAlert() {
        let alertEl = document.getElementById("wallet-alert");
        if (!alertEl) {
          alertEl = document.createElement("div");
          alertEl.id = "wallet-alert";
          alertEl.style.position = "fixed";
          alertEl.style.inset = "0";
          alertEl.style.display = "flex";
          alertEl.style.alignItems = "center";
          alertEl.style.justifyContent = "center";
          alertEl.style.background = "rgba(0,0,0,0.7)";
          alertEl.style.zIndex = "70";
          alertEl.innerHTML = `
            <div style="
              min-width:260px;
              max-width:360px;
              padding:14px 16px 10px;
              border-radius:10px;
              border:1px solid rgba(212,175,55,0.8);
              background:linear-gradient(180deg,rgba(10,10,18,0.98),rgba(5,5,16,0.98));
              box-shadow:0 0 22px rgba(0,234,255,0.35), inset 0 0 10px rgba(212,175,55,0.28);
              font-family:Cinzel,serif;
              text-align:center;
              color:#e8faff;
            ">
              <div style="font-size:15px;font-weight:800;letter-spacing:1px;text-transform:uppercase;margin-bottom:4px;text-shadow:0 0 6px rgba(0,234,255,0.65);">
                Connect wallet first
              </div>
              <div style="font-size:10px;opacity:0.86;margin-bottom:10px;font-family:Orbitron,system-ui,sans-serif;">
                Link a Cardano wallet to begin opening ADA Arcana packs.
              </div>
              <div style="display:flex;gap:8px;justify-content:center;">
                <button id="wallet-alert-connect" class="btn btn-primary" style="padding:5px 14px;font-size:10px;">
                  Open Wallets
                </button>
                <button id="wallet-alert-close" class="btn" style="padding:5px 10px;font-size:10px;">
                  Close
                </button>
              </div>
            </div>
          `;
          document.body.appendChild(alertEl);

          const connectBtn = document.getElementById("wallet-alert-connect");
          const closeBtn = document.getElementById("wallet-alert-close");

          if (connectBtn && !connectBtn._bound) {
            connectBtn.addEventListener("click", () => {
              alertEl.style.display = "none";
              const backdrop = document.getElementById("wallet-modal-backdrop");
              if (backdrop) {
                updateWalletDetection();
                backdrop.style.display = "flex";
              }
            });
            connectBtn._bound = true;
          }

          if (closeBtn && !closeBtn._bound) {
            closeBtn.addEventListener("click", () => {
              alertEl.style.display = "none";
            });
            closeBtn._bound = true;
          }

          alertEl.addEventListener("click", e => {
            if (e.target === alertEl) {
              alertEl.style.display = "none";
            }
          });
        } else {
          alertEl.style.display = "flex";
        }

        // Ensure alert is visible above everything
        alertEl.style.zIndex = "70";

        // Re-bind buttons on subsequent shows in case DOM changed
        const connectBtn2 = document.getElementById("wallet-alert-connect");
        const closeBtn2 = document.getElementById("wallet-alert-close");

        if (connectBtn2 && !connectBtn2._bound) {
          connectBtn2.addEventListener("click", () => {
            alertEl.style.display = "none";
            const backdrop = document.getElementById("wallet-modal-backdrop");
            if (backdrop) {
              updateWalletDetection();
              backdrop.style.display = "flex";
            }
          });
          connectBtn2._bound = true;
        }

        if (closeBtn2 && !closeBtn2._bound) {
          closeBtn2.addEventListener("click", () => {
            alertEl.style.display = "none";
          });
          closeBtn2._bound = true;
        }
      }

      // Click handler: gate pack opening on wallet connection and integrate alert
      function onClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        const packModal = document.getElementById("pack-selection");
        if (packModal && getComputedStyle(packModal).display !== "none") {
          // Ignore 3D scene clicks while pack selection modal is open
          return;
        }

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0) {
          const object = intersects[0].object;

          // If user clicks on the pack while not connected: show alert + wallet modal
          if (object.name === "pack" && !isWalletConnected()) {
            showConnectWalletAlert();
            const backdrop = document.getElementById("wallet-modal-backdrop");
            if (backdrop) {
              updateWalletDetection();
              backdrop.style.display = "flex";
            }
            return;
          }

          // Normal gated open when connected
          if (object.name === "pack" && !isOpening && !packOpened && isWalletConnected()) {
            // Enforce: must own an appropriate pack to open.
            if (!tryConsumeForPack(SELECTED_PACK)) {
              // No inventory pack for this selection: send user back to pack selection.
              const instr = document.getElementById("instruction");
              if (instr) {
                const prev = instr.getAttribute("data-prev") || instr.textContent;
                instr.setAttribute("data-prev", prev);
                instr.textContent = "No packs detected for this type. Select a different pack.";
              }

              // Re-open pack selection modal so user can choose another pack.
              try {
                renderPackSelection();
              } catch (e) {
                console.warn("Failed to re-open pack selection after missing pack balance.", e);
              }

              return;
            }

            // Proceed with open, pack was successfully consumed.
            if (typeof renderProfilePackCounts === "function") {
              renderProfilePackCounts();
            }
            openPackSequence();
            return;
          }

          // Flip cards when opened
          if (object.userData?.isCard && packOpened && !object.userData.flipped) {
            flipCard(object);
            return;
          }
        }
        // Other clicks fall through to their own handlers
      }

      function onMouseMove(event) {
        mouse.x =
          (event.clientX /
            window.innerWidth) *
            2 -
          1;
        mouse.y =
          -(event.clientY /
            window.innerHeight) *
            2 +
          1;

        if (packOpened) {
          raycaster.setFromCamera(
            mouse,
            camera
          );
          const intersects =
            raycaster.intersectObjects(
              cards
            );
          cards.forEach(c => {
            if (!c.userData.flipped) {
              gsap.to(c.scale, {
                x: 1,
                y: 1,
                z: 1,
                duration: 0.3
              });
            }
          });
          const hovered =
            intersects.length > 0
              ? intersects[0].object
              : null;
          if (
            hovered?.userData
              ?.isCard
          ) {
            document.body.style.cursor =
              "pointer";
            if (!hovered.userData.flipped) {
              gsap.to(
                hovered.scale,
                {
                  x: 1.1,
                  y: 1.1,
                  z: 1.1,
                  duration: 0.3
                }
              );
              HoverTooltip.hide();
            } else {
              gsap.to(
                hovered.scale,
                {
                  x: 1.1,
                  y: 1.1,
                  z: 1.1,
                  duration: 0.3
                }
              );
              HoverTooltip.show(
                event.clientX,
                event.clientY,
                {
                  name: hovered.userData
                    .name,
                  rarity:
                    hovered.userData
                      .rarity,
                  description:
                    hovered.userData
                      .description
                }
              );
            }
          } else {
            document.body.style.cursor =
              "default";
            HoverTooltip.hide();
          }
        }
      }

      function openPackSequence() {
        isOpening = true;
        const instr =
          document.getElementById(
            "instruction"
          );
        if (instr)
          instr.textContent =
            "Decoding sequence...";

        const tl = gsap.timeline({
          onComplete: () => {
            scene.remove(packMesh);
            spawnCards();
          }
        });

        tl.to(
          packMesh.rotation,
          {
            x: Math.PI * 0.1,
            y: "+=15",
            duration: 2,
            ease: "power2.in"
          },
          0
        );
        tl.to(
          packMesh.scale,
          {
            x: 1.2,
            y: 1.2,
            z: 1.2,
            duration: 1.8,
            ease: "elastic.in(1,0.3)"
          },
          0
        );
        tl.to(
          packMesh.scale,
          {
            x: 0.01,
            y: 0.01,
            z: 0.01,
            duration: 0.3,
            ease: "power4.in"
          }
        );
      }

      async function spawnCards() {
        const cardCount =
          (SELECTED_PACK &&
            SELECTED_PACK
              .cards_per_pack) ||
          5;
        revealedCount = 0;

        await Promise.all([
          CARD_DATA_READY,
          PACK_DATA_READY
        ]);

        if (
          !CARD_DATA ||
          CARD_DATA.length === 0
        ) {
          console.warn(
            "CARD_DATA is empty."
          );
          return;
        }

        const usedNames =
          new Set();
        function pickRandomCardByRarity(
          targetR
        ) {
          const target =
            normalizeRarityStr(
              targetR
            );
          const fallbacks = {
            celestials: [
              "mythic",
              "legendary",
              "epic",
              "rare",
              "uncommon",
              "common"
            ],
            mythic: [
              "legendary",
              "epic",
              "rare",
              "uncommon",
              "common"
            ],
            legendary: [
              "epic",
              "rare",
              "uncommon",
              "common"
            ],
            epic: ["rare", "uncommon", "common"],
            rare: ["uncommon", "common"],
            uncommon: ["common"],
            common: []
          };
          const tryRarities = [
            target,
            ...(fallbacks[target] || [])
          ];
          for (const r of tryRarities) {
            const list =
              CARD_DATA.filter(
                c =>
                  normalizeRarityStr(
                    c.rarity
                  ) ===
                    normalizeRarityStr(
                      r
                    ) &&
                  !usedNames.has(
                    c.name
                  )
              );
            if (list.length > 0) {
              const choice =
                list[
                  Math.floor(
                    Math.random() *
                      list.length
                  )
                ];
              usedNames.add(choice.name);
              return choice;
            }
          }
          const unused =
            CARD_DATA.filter(
              c =>
                !usedNames.has(
                  c.name
                )
            );
          const base =
            unused.length
              ? unused
              : CARD_DATA;
          return base[
            Math.floor(
              Math.random() *
                base.length
            )
          ];
        }

        const picked = [];
        for (let i = 0; i < cardCount; i++) {
          const rarity = generateRarity();
          picked.push(pickRandomCardByRarity(rarity));
        }

        Inventory.addMany(picked.map(c => c.id));
        Inventory.render();

        // Persist pack open + cards in Supabase
        try {
          if (currentUserId) {
            const packType = SELECTED_PACK
              ? (SELECTED_PACK.pack_name || "GENESIS_SIGIL")
              : "GENESIS_SIGIL";

            await logPackOpen({
              userId: currentUserId,
              packType,
              source: "DIRECT",
              cards: picked.map(c => ({
                card_def_id: c.id,
                rarity: c.rarity || null,
                name: c.name || null,
                description: c.description || null,
                image_url: c.image || null
              }))
            });

            // Also sync current pack balances snapshot
            if (typeof getPackBalances === "function") {
              const balances = getPackBalances();
              await savePackBalances(currentUserId, balances);
            }
          }
        } catch (e) {
          console.error("[supabase] failed to persist pack open/cards", e);
        }

        cards = [];
        for (let i = 0; i < picked.length; i++) {
          const card = createCard(
            picked[i],
            i,
            cardCount
          );
          card.position.set(
            0,
            0,
            -1
          );
          card.rotation.y =
            Math.PI;
          card.scale.set(0, 0, 0);
          scene.add(card);
          cards.push(card);
        }

        const tl = gsap.timeline({
          onComplete: () => {
            isOpening = false;
            packOpened = true;
            const instr =
              document.getElementById(
                "instruction"
              );
            if (instr)
              instr.textContent =
                "Click cards to reveal";
          }
        });

        cards.forEach((card, i) => {
          tl.to(
            card.scale,
            {
              x: 1,
              y: 1,
              z: 1,
              duration: 0.4,
              ease: "back.out(1.7)"
            },
            i * 0.1
          );
          tl.to(
            card.position,
            {
              x: card.userData.basePos.x,
              y: card.userData.basePos.y,
              z: card.userData.basePos.z,
              duration: 0.8,
              ease: "power3.out"
            },
            i * 0.1
          );
          tl.to(
            card.rotation,
            {
              z:
                (Math.random() -
                  0.5) *
                0.2,
              duration: 0.8
            },
            i * 0.1
          );
        });
      }

      function flipCard(card) {
        if (card.userData.flipped) return;
        card.userData.flipped = true;

        gsap.to(card.rotation, {
          y: Math.PI * 2,
          duration: 0.8,
          ease: "back.out(1.5)",
          onComplete: () => {
            showCardInfo(card);
            revealedCount++;
            if (
              revealedCount >=
              cards.length
            ) {
              const instr =
                document.getElementById(
                  "instruction"
                );
              if (instr)
                instr.textContent =
                  "All cards revealed";
              showPostOpenButtons();
            }
            if (
              card.userData.rarity !==
              "common"
            ) {
              gsap.to(
                card.material[4],
                {
                  emissiveIntensity:
                    card.userData
                      .glowIntensity,
                  duration: 0.5
                }
              );
            }
          }
        });

        gsap.to(card.position, {
          z: 1.5,
          y: 0.5,
          duration: 0.4,
          yoyo: true,
          repeat: 1,
          ease: "sine.out"
        });
        gsap.to(card.rotation, {
          z: 0,
          duration: 0.4
        });
      }

      function onWindowResize() {
        camera.aspect =
          window.innerWidth /
          window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(
          window.innerWidth,
          window.innerHeight
        );
        composer.setSize(
          window.innerWidth,
          window.innerHeight
        );
      }

      function animate() {
        requestAnimationFrame(animate);
        if (packOpened) {
          const time =
            performance.now() *
            0.001;
          cards.forEach((card, i) => {
            if (
              !card.userData
                .flipped
            ) {
              card.position.y =
                Math.sin(
                  time + i
                ) * 0.1;
            }
          });
        }
        composer.render();
      }
    </script>
  </body>
</html>
